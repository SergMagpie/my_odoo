# Конкатенация (сложение)
>>> s1 = 'spam'
>>> s2 = 'eggs'
>>> print(s1 + s2)
'spameggs'

# Дублирование строки
>>> print('spam' * 3)
spamspamspam

# Длина строки
>>> len('spam')
4

# Доступ по индексу
>>> S = 'spam'
>>> S[0]
's'
>>> S[2]
'a'
>>> S[-2]
'a'

# Срез
>>> s = 'spameggs'
>>> s[3:5]
'me'
>>> s[2:-2]
'ameg'
>>> s[:6]
'spameg'
>>> s[1:]
'pameggs'
>>> s[:]
'spameggs'

# Шаг, извлечения среза
>>> s[::-1]
'sggemaps'
>>> s[3:5:-1]
''
>>> s[2::2]
'aeg'


# Литералы строк
S = 'str'; S = "str"; S = '''str'''; S = """str"""
# Экранированные последовательности
S = "s\np\ta\nbbb"
# Неформатированные строки (подавляют экранирование)
S = r"C:\temp\new"
# Строка байтов
S = b"byte"
# Конкатенация (сложение строк)
S1 + S2
# Повторение строки
S1 * 3
# Обращение по индексу
S[i]
# Извлечение среза
S[i:j:step]
# Длина строки
len(S)
# Поиск подстроки в строке. Возвращает номер первого вхождения или -1
S.find(str, [start],[end])
# Поиск подстроки в строке. Возвращает номер последнего вхождения или -1
S.rfind(str, [start],[end])
# Поиск подстроки в строке. Возвращает номер первого вхождения или вызывает ValueError
S.index(str, [start],[end])
# Поиск подстроки в строке. Возвращает номер последнего вхождения или вызывает ValueError
S.rindex(str, [start],[end])
# Замена шаблона
S.replace(шаблон, замена)
# Разбиение строки по разделителю
S.split(символ)
# Состоит ли строка из цифр
S.isdigit()
# Состоит ли строка из букв
S.isalpha()
# Состоит ли строка из цифр или букв
S.isalnum()
# Состоит ли строка из символов в нижнем регистре
S.islower()
# Состоит ли строка из символов в верхнем регистре
S.isupper()
# Состоит ли строка из неотображаемых символов (пробел, символ перевода страницы ('\f'), "новая строка" ('\n'), "перевод каретки" ('\r'), "горизонтальная табуляция" ('\t') и "вертикальная табуляция" ('\v'))
S.isspace()
# Начинаются ли слова в строке с заглавной буквы
S.istitle()
# Преобразование строки к верхнему регистру
S.upper()
# Преобразование строки к нижнему регистру
S.lower()
# Начинается ли строка S с шаблона str
S.startswith(str)
# Заканчивается ли строка S шаблоном str
S.endswith(str)
# Сборка строки из списка с разделителем S
S.join(список)
# Символ в его код ASCII
ord(символ)
# Код ASCII в символ
chr(число)
# Переводит первый символ строки в верхний регистр, а все остальные в нижний
S.capitalize()
# Возвращает отцентрованную строку, по краям которой стоит символ fill (пробел по умолчанию)
S.center(width, [fill])
# Возвращает количество непересекающихся вхождений подстроки в диапазоне [начало, конец] (0 и длина строки по умолчанию)
S.count(str, [start],[end])
# Возвращает копию строки, в которой все символы табуляции заменяются одним или несколькими пробелами, в зависимости от текущего столбца. Если TabSize не указан, размер табуляции полагается равным 8 пробелам
S.expandtabs([tabsize])
# Удаление пробельных символов в начале строки
S.lstrip([chars])
# Удаление пробельных символов в конце строки
S.rstrip([chars])
# Удаление пробельных символов в начале и в конце строки
S.strip([chars])
# Возвращает кортеж, содержащий часть перед первым шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий саму строку, а затем две пустых строки
S.partition(шаблон)
# Возвращает кортеж, содержащий часть перед последним шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий две пустых строки, а затем саму строку
S.rpartition(sep)
# Переводит символы нижнего регистра в верхний, а верхнего – в нижний
S.swapcase()
# Первую букву каждого слова переводит в верхний регистр, а все остальные в нижний
S.title()
# Делает длину строки не меньшей width, по необходимости заполняя первые символы нулями
S.zfill(width)
# Делает длину строки не меньшей width, по необходимости заполняя последние символы символом fillchar
S.ljust(width, fillchar=" ")
# Делает длину строки не меньшей width, по необходимости заполняя первые символы символом fillchar
S.rjust(width, fillchar=" ")

S = 'str'; S = "str"; S = '''str'''; S = """str"""

S1 + S2 Конкатенация (сложение строк)

S1 * 3 Повторение строки

S[i] Обращение по индексу

S[i:j:step] Извлечение среза

len(S) Длина строки

S.find(str, [start],[end]) Поиск подстроки в строке. Возвращает номер первого вхождения или -1

S.rfind(str, [start],[end]) Поиск подстроки в строке. Возвращает номер последнего вхождения или -1

S.index(str, [start],[end]) Поиск подстроки в строке. Возвращает номер первого вхождения или вызывает ValueError

S.rindex(str, [start],[end]) Поиск подстроки в строке. Возвращает номер последнего вхождения или вызывает ValueError

S.replace(шаблон, замена) Замена шаблона

S.split(символ) Разбиение строки по разделителю

S.isdigit() Состоит ли строка из цифр

S.isalpha() Состоит ли строка из букв

S.isalnum() Состоит ли строка из цифр или букв

S.islower() Состоит ли строка из символов в нижнем регистре

S.isupper() Состоит ли строка из символов в верхнем регистре

S.isspace() Состоит ли строка из неотображаемых символов (пробел, символ перевода страницы ('\f'), "новая строка" ('\n'), "перевод каретки" ('\r'), "горизонтальная табуляция" ('\t') и "вертикальная табуляция" ('\v'))

S.istitle() Начинаются ли слова в строке с заглавной буквы

S.upper() Преобразование строки к верхнему регистру

S.lower() Преобразование строки к нижнему регистру

S.startswith(str) Начинается ли строка S с шаблона str

S.endswith(str) Заканчивается ли строка S шаблоном str

S.join(список) Сборка строки из списка с разделителем S

ord(символ) Символ в его код ASCII

chr(число) Код ASCII в символ

S.capitalize() Переводит первый символ строки в верхний регистр, а все остальные в нижний

S.center(width, [fill]) Возвращает отцентрованную строку, по краям которой стоит символ fill (пробел по умолчанию)

S.count(str, [start],[end]) Возвращает количество непересекающихся вхождений подстроки в диапазоне [начало, конец] (0 и длина строки по умолчанию)

S.expandtabs([tabsize]) Возвращает копию строки, в которой все символы табуляции заменяются одним или несколькими пробелами, в зависимости от текущего столбца. Если TabSize не указан, размер табуляции полагается равным 8 пробелам

S.lstrip([chars]) Удаление пробельных символов в начале строки

S.rstrip([chars]) Удаление пробельных символов в конце строки

S.strip([chars]) Удаление пробельных символов в начале и в конце строки

S.partition(шаблон) Возвращает кортеж, содержащий часть перед первым шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий саму строку, а затем две пустых строки

S.rpartition(sep) Возвращает кортеж, содержащий часть перед последним шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий две пустых строки, а затем саму строку

S.swapcase() Переводит символы нижнего регистра в верхний, а верхнего – в нижний

S.title() Первую букву каждого слова переводит в верхний регистр, а все остальные в нижний

S.zfill(width) Делает длину строки не меньшей width, по необходимости заполняя первые символы нулями

S.ljust(width, fillchar=" ") Делает длину строки не меньшей width, по необходимости заполняя последние символы символом fillchar

S.rjust(width, fillchar=" ") Делает длину строки не меньшей width, по необходимости заполняя первые символы символом fillchar

Форматирование чисел с format()
С помощью спецификаторов формата можно форматировать и числа:

Типы форматирования чисел
Тип	Значение
d	Десятичное число
c	Соответствующий символ Unicode
b	Двоичный формат
o	Восьмеричный формат
x	Шестнадцатеричный формат (в нижнем регистре)
X	Шестнадцатеричный формат (в верхнем регистре)
n	То же, что и d, но использует местную настройку для разделения числа
e	Экспоненциальная запись (e в нижнем регистре)
E	Экспоненциальная запись (E в верхнем регистре)
f	Отображать фиксированное количество знаков (по умолчанию 6)
F	То же, что и f, только отображает inf как INF, а nan как NAN
g	Общий формат. Округляет число до p значащих цифр (Точность по умолчанию: 6)
G	То же, что и g. Но переключается к E, если число очень большое
%	Проценты. Делит на 100 и добавляет % в конце

# целочисленные аргументы
print("The number is:{:d}".format(123))

# аргументы с плавающей точкой
print("The float number is:{:f}".format(123.4567898))

# восьмеричный, двоичный и шестнадцатеричный формат
print("bin: {0:b}, oct: {0:o}, hex: {0:x}".format(12))

# целые числа с минимальной шириной
print("{:5d}".format(12))

# ширина не работает для чисел длиннее заполнения
print("{:2d}".format(1234))

# заполнение для чисел с плавающей точкой
print("{:8.3f}".format(12.2346))

# целые числа с минимальной шириной, заполненные нулями
print("{:05d}".format(12))

# заполнение для чисел с плавающей запятой, заполненных нулями
print("{:08.3f}".format(12.2346))

# показать знак +
print("{:+f} {:+f}".format(12.23, -12.23))

# показать знак - 
print("{:-f} {:-f}".format(12.23, -12.23))

# показать место для знака +
print("{: f} {: f}".format(12.23, -12.23))

Форматирование чисел с выравниванием
Тип	Значение
<	Выравнивается по левому краю
^	Выравнивается по центру
>	Выравнивается по правому краю
=	Сдвигает знаки (+ или -) к левой позиции

# целые числа с выравниванием по правому краю
print("{:5d}".format(12))

# числа с плавающей точкой с выравниванием по центру
print("{:^10.3f}".format(12.2346))

# выравнивание целого числа по левому краю заполнено нулями
print("{:<05d}".format(12))

# числа с плавающей точкой с выравниванием по центру
print("{:=8.3f}".format(-12.2346))

# отступ строки с выравниванием по левому краю
print("{:5}".format("cat"))

# отступ строки с выравниванием по правому краю
print("{:>5}".format("cat"))

# заполнение строк с выравниванием по центру
print("{:^5}".format("cat"))

# заполнение строк с выравниванием по центру
# и '*' - символ заполнения
print("{:*^5}".format("cat"))

# обрезание строк до 3 букв
print("{:.3}.".format("caterpillar"))

# обрезание строк до 3 букв и заполнение
print("{:5.3}.".format("caterpillar"))

# обрезание строк до 3 букв,
# заполнение и выравнивание по центру
print("{:^5.3}.".format("caterpillar"))

# определяем класс Person
class Person:
    age = 23
    name = "Adam"

# форматирование возраста
print("{p.name}'s age is: {p.age}".format(p=Person()))

# объявляем словарь person
person = {'age': 23, 'name': 'Adam'}

# форматирование возраста
print("{p[name]}'s age is: {p[age]}".format(p=person))

# объявляем словарь person
person = {'age': 23, 'name': 'Adam'}

# форматирование возраста
print("{name}'s age is: {age}".format(**person))

# динамический шаблон формата строки
string = "{:{fill}{align}{width}}"

# передача кодов формата в качестве аргументов
print(string.format('cat', fill='*', align='^', width=5))

# динамический шаблон формата float
num = "{:{align}{width}.{precision}f}"

# передача кодов формата в качестве аргументов
print(num.format(123.236, align='<', width=8, precision=2))

import datetime
# datetime форматирование
date = datetime.datetime.now()
print("It's now: {:%Y/%m/%d %H:%M:%S}".format(date))

# форматирование комплексных чисел
complexNumber = 1+2j
print("Real part: {0.real} and Imaginary part: {0.imag}".format(complexNumber))

# пользовательский метод __format__()
class Person:
    def __format__(self, format):
        if(format == 'age'):
            return '23'
        return 'None'

print("Adam's age is: {:age}".format(Person()))

# __str__() и __repr__() сокращенно !r и !s
print("Quotes: {0!r}, Without Quotes: {0!s}".format("cat"))

# реализация для класса __str__() и __repr__()
class Person:
    def __str__(self):
        return "STR"
    def __repr__(self):
        return "REPR"

print("repr: {p!r}, str: {p!s}".format(p=Person()))

>>> coord = (3, 5)
>>> 'X: {0[0]};  Y: {0[1]}'.format(coord)
'X: 3;  Y: 5'
>>> "repr() shows quotes: {!r}; str() doesn't: {!s}".format('test1', 'test2')
"repr() shows quotes: 'test1'; str() doesn't: test2"
>>> '{:<30}'.format('left aligned')
'left aligned                  '
>>> '{:>30}'.format('right aligned')
'                 right aligned'
>>> '{:^30}'.format('centered')
'           centered           '
>>> '{:*^30}'.format('centered')  # use '*' as a fill char
'***********centered***********'
>>> '{:+f}; {:+f}'.format(3.14, -3.14)  # show it always
'+3.140000; -3.140000'
>>> '{: f}; {: f}'.format(3.14, -3.14)  # show a space for positive numbers
' 3.140000; -3.140000'
>>> '{:-f}; {:-f}'.format(3.14, -3.14)  # show only the minus -- same as '{:f}; {:f}'
'3.140000; -3.140000'
>>> # format also supports binary numbers
>>> "int: {0:d};  hex: {0:x};  oct: {0:o};  bin: {0:b}".format(42)
'int: 42;  hex: 2a;  oct: 52;  bin: 101010'
>>> # with 0x, 0o, or 0b as prefix:
>>> "int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}".format(42)
'int: 42;  hex: 0x2a;  oct: 0o52;  bin: 0b101010'
>>> points = 19.5
>>> total = 22
>>> 'Correct answers: {:.2%}'.format(points/total)
'Correct answers: 88.64%'

[el for lst in s for el in lst] # так я раскрываю вложенный список s

print(*map(lambda i: i.split('#')[0].rstrip(), __import__('sys').stdin.read().splitlines()[1:]), sep='\n')

>>> a = [10, 20, 30, 40]
>>> for i in enumerate(a):
...     print(i)
... 
(0, 10)
(1, 20)
(2, 30)
(3, 40)