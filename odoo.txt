Добавление вычисляемых полей в модель

Иногда нам нужно иметь поле, значение которого вычислено или получено из других полей. в той же записи или в связанных записях. Типичный пример - общая сумма, которая рассчитывается путем умножения цены за единицу на количество. В моделях Odoo этого можно добиться с использованием вычисляемых полей.
Чтобы показать вам, как работают вычисляемые поля, мы добавим одно в модель Библиотечной книги. для подсчета дней, прошедших с даты выхода книги.
Также можно сделать вычисляемые поля доступными для редактирования и поиска. Мы реализуем это к нашему примеру.

Готовиться
Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...
Мы отредактируем файл кода models/library_book.py, чтобы добавить новое поле и методы, поддерживающие его логику:

1. Начните с добавления нового поля в модель Library Books:
class LibraryBook(models.Model):
	# ...
	age_days = fields.Float(
		string='Days Since Release',
		compute='_compute_age',
		inverse='_inverse_age',
		search='_search_age',
		store=False,	# optional
		compute_sudo=True # optional
	)

2. Затем добавьте метод с логикой вычисления значения:

# ...
from odoo import api # if not already imported
# ...
class LibraryBook(models.Model):
	# ...
	@api.depends('date_release')
	def _compute_age(self):
		today = fields.Date.today()
		for book in self:
			if book.date_release:
				delta = today - book.date_release
				book.age_days = delta.days
			else:
				book.age_days = 0

3. Чтобы добавить метод и реализовать логику записи в вычисляемом поле, используйте следующий код:

from datetime import timedelta
# ...
class LibraryBook(models.Model):
	# ...
	def _inverse_age(self):
		today = fields.Date.today()
		for book in self.filtered('date_release'):
			d = today - timedelta(days=book.age_days)
			book.date_release = d

4. Чтобы реализовать логику, которая позволит вам искать в вычисляемом поле, используйте следующий код:

from datetime import timedelta
class LibraryBook(models.Model):
    # ...
    def _search_age(self, operator, value):
        today = fields.Date.today()
        value_days = timedelta(days=value)
        value_date = today - value_days
        # convert the operator:
        # book with age > value have a date < value_date
        operator_map = {
            '>': '<', '>=': '<=',
            '<': '>', '<=': '>=',
        }
        new_op = operator_map.get(operator, operator)
        return [('date_release', new_op, value_date)]

Перезагрузка Odoo с последующим обновлением модуля необходима для правильной активации этих новых
дополненй.        

Как это работает...

Определение вычисляемого поля такое же, как определение обычного поля, за исключением того, что
добавлен атрибут compute, чтобы указать имя метода, который будет использоваться для его
вычисления.

Их сходство может быть обманчивым, поскольку вычисляемые поля внутренне сильно отличаются от
регулярных полей. Вычисляемые поля динамически вычисляются во время выполнения, и поэтому
они не хранятся в базе данных, поэтому вы не можете выполнять поиск или запись в полях вычислений 
по умолчанию. Вам нужно проделать некоторую дополнительную работу, чтобы включить поддержку записи и поиска для
вычисляемого поля. Посмотрим, как это сделать.

Функция вычисления динамически вычисляется во время выполнения, но ORM использует
кэширование, чтобы избежать неэффективного пересчета при каждом обращении к его значению. Итак, необходимо
знать, от каких еще полей это зависит. Он использует декоратор @depends, чтобы определить, когда его
кэшированные значения должны быть признаны недействительными и пересчитаны.

Убедитесь, что функция вычисления всегда устанавливает значение в вычисляемом поле. Иначе,
возникнет ошибка. Это может произойти, если в вашем коде есть условия, значения которых
иногда не удается установить в вычисляемом поле. Это может быть сложно отладить.

Поддержка записи может быть добавлена ​​путем реализации обратной функции. Здесь значение
вычисляемого поля обновляется при обновлении оригинального поля. Конечно, это имеет смысл только
для простых расчетов. Тем не менее, есть случаи, когда это может быть полезно. В
В нашем примере мы даем возможность установить дату выпуска книги, отредактировав вычисляемое 
поле «Дни с момента выпуска». Обратный атрибут не является обязательным; если вы не хотите, 
чтобы вычисляемое поле редактировалось, вы можете пропустить его.

Также возможно сделать несохраненное вычисляемое поле доступным для поиска, установив
атрибут поиска по имени метода (аналогично вычислению и обратному). Как и в обратном порядке, 
поиск также необязателен; если вы не хотите делать поле вычислений доступным для поиска, вы можете
пропусти это.

Однако не ожидается, что этот метод будет реализовывать фактический поиск. Вместо этого он получает 
в качестве параметров оператор и значение, используемые для поиска в поле, и, как ожидается, вернет 
домен с используемыми условиями поиска замены. В нашем примере мы переводим поиск в 
поле «Дни с момента выпуска» в эквивалентное условие поиска в поле «Дата выпуска».

Необязательный флаг store = True сохраняет поле в базе данных. В этом случае после вычисления значения 
полей сохраняются в базе данных, и оттуда они извлекаются так же, как и обычные поля, вместо того, чтобы 
повторно вычисляться во время выполнения. Благодаря декоратору @api.depends ORM будет знать, когда 
эти сохраненные значения необходимо пересчитать и обновить. Вы можете думать об этом как о постоянном 
кеше. Он также имеет то преимущество, что делает поле пригодным для использования в условиях поиска, 
включая сортировку и группировку по операциям. Если вы используете store = True в своем поле вычислений, 
вам больше не нужно реализовывать метод поиска, потому что поле хранится в базе данных, и вы можете 
искать / сортировать на основе сохраненного поля.

Флаг compute_sudo = True должен использоваться в случаях, когда вычисления должны выполняться с 
повышенными привилегиями. Это может быть тот случай, когда при вычислении необходимо использовать 
данные, которые могут быть недоступны для конечного пользователя.

Важная заметка
Значение по умолчанию compute_sudo изменено в Odoo v13. До Odoo v13 значение compute_sudo было 
False. Но в версии 13 значение по умолчанию compute_sudo будет основано на атрибутах хранилища. 
Если значение атрибута store равно True, то compute_sudo равно True или False.
Однако вы всегда можете изменить его вручную, явно указав compute_sudo в определении поля.

Есть больше...
Odoo v13 представил новый механизм кеширования для ORM. Раньше кеш был основан на окружении, 
но теперь в Odoo v13 у нас есть один глобальный кеш. Итак, если у вас есть вычисляемое поле, 
которое зависит от значений контекста, вы можете иногда получать неверные значения. Чтобы 
решить эту проблему, вам нужно использовать декоратор @api.depends_context.
Обратитесь к следующему примеру:

@api.depends('price')
@api.depends_context('company_id')
def _compute_value(self):
    company_id = self.env.context.get('company_id')
    ...
    # other computation

В предыдущем примере вы можете видеть, что в нашем вычислении используется company_id из 
контекста. Используя company_id в декораторе depends_context, мы гарантируем, что значение 
поля будет пересчитано на основе значения company_id в контексте.

Отображение связанных полей, хранящихся в других моделях

При чтении данных с сервера клиенты Odoo могут получать значения только для тех полей, 
которые доступны в модели и запрашиваются. Код на стороне клиента, в отличие от кода на 
стороне сервера, не может использовать точечную нотацию для доступа к данным в связанных таблицах.

Однако эти поля можно сделать доступными там, добавив их как связанные поля. Мы сделаем это, 
чтобы город издателя был доступен в модели «Library Books».

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Отредактируйте файл models /library_book.py, чтобы добавить новое связанное поле:

1. Убедитесь, что у нас есть поле для издателя книги:

class LibraryBook(models.Model):
    # ...
    publisher_id = fields.Many2one(
        'res.partner', string='Publisher')

2. Теперь добавьте соответствующее поле для города издателя:

# class LibraryBook(models.Model):
    # ...
    publisher_city = fields.Char(
        'Publisher City',
        related='publisher_id.city',
        readonly=True)
    
Наконец, нам нужно обновить дополнительный модуль, чтобы новые поля были доступны в модели.

Как это работает...

Связанные поля аналогичны обычным полям, но у них есть дополнительный атрибут, связанный со 
строкой для отдельной цепочки полей, которую необходимо пройти.

В нашем случае мы получаем доступ к записи, связанной с издателем, через publisher_id, а 
затем читаем ее поле города. У нас также могут быть более длинные цепочки, например 
publisher_id.country_id.country_code.

Обратите внимание, что в этом рецепте мы устанавливаем связанное поле только для чтения. 
Если мы этого не сделаем, поле будет доступно для записи, и пользователь может изменить его 
значение. Это приведет к изменению значения поля города связанного издателя. Хотя это может 
быть полезным побочным эффектом, следует проявлять осторожность. У всех книг, опубликованных 
одним и тем же издателем, будет обновлено поле publisher_city, что может не соответствовать 
ожиданиям пользователя.

Есть больше...

Связанные поля фактически являются вычисляемыми полями. Они просто предоставляют удобный 
сокращенный синтаксис для чтения значений полей из связанных моделей. В качестве вычисляемого 
поля это означает, что атрибут store также доступен. В качестве ярлыка они также имеют все атрибуты 
из указанного поля, такие как name, translatable, если требуется.

Кроме того, они поддерживают флаг related_sudo, аналогичный compute_sudo; если установлено значение 
True, цепочка полей просматривается без проверки прав доступа пользователя.

Использование связанных полей в методе create() может повлиять на производительность, поскольку 
вычисление этих полей откладывается до конца их создания. Итак, если у вас есть отношение One2many, 
например, в моделях sale.order и sale.order.line, и у вас есть связанное поле в линейной модели, 
ссылающееся на поле в модели заказа, вы должны явно прочитать поле в модель заказа во время создания 
записи, вместо использования ярлыка связанного поля, особенно если есть много строк.

Добавление динамических отношений с использованием справочных полей

В случае реляционных полей нам необходимо заранее определить целевую модель (или совместную модель) 
отношения. Однако иногда нам может потребоваться оставить это решение на усмотрение пользователя и 
сначала выбрать желаемую модель, а затем запись, на которую мы хотим создать ссылку.

В Odoo этого можно добиться с помощью справочных полей.

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Отредактируйте файл models /library_book.py, чтобы добавить новое связанное поле:

1. Во-первых, нам нужно добавить вспомогательный метод для динамического построения списка выбираемых 
целевых моделей:

from odoo import models, fields, api
class LibraryBook(models.Model):
    # ...
    @api.model
    def _referencable_models(self):
        models = self.env['ir.model'].search([
            ('field_id.name', '=', 'message_ids')])
        return [(x.model, x.name) for x in models]

2. Затем нам нужно добавить поле ссылки и использовать предыдущую функцию, чтобы предоставить 
список выбираемых моделей:        

ref_doc_id = fields.Reference(
    selection='_referencable_models',
    string='Reference Document')

Поскольку мы меняем структуру модели, для активации этих изменений необходимо обновление модуля.

Как это работает...

Справочные поля аналогичны полям типа "многие к одному", за исключением того, что они 
позволяют пользователю выбрать модель для ссылки.

Целевую модель можно выбрать из списка, предоставленного атрибутом selection. Атрибут 
selection должен быть списком из двух кортежей элементов, где первый - это внутренний идентификатор 
модели, а второй - ее текстовое описание.

Вот пример:

[('res.users', 'User'), ('res.partner', 'Partner')]

Однако вместо того, чтобы предоставлять фиксированный список, мы можем использовать наиболее 
распространенные модели. Для простоты мы используем все модели, в которых есть функция обмена 
сообщениями. Используя метод _referencable_models, мы предоставили список моделей динамически.

Наш рецепт начался с предоставления функции для просмотра всех записей модели, на которые можно ссылаться, 
для динамического создания списка, который будет предоставлен атрибуту выбора.
Хотя обе формы разрешены, мы объявили имя функции в кавычках, вместо того, чтобы напрямую 
ссылаться на функцию без кавычек. Это более гибкий подход, и он позволяет, например, определять 
функцию, на которую указывает ссылка, только позже в коде, что невозможно при использовании прямой ссылки.

Добавление функций в модель с помощью наследования

Одной из наиболее важных функций Odoo является способность надстроек модулей расширять функции, 
определенные в других надстройках модулей, без необходимости редактировать код исходной функции. 
Это может быть добавление полей или методов, изменение существующих полей или расширение существующих 
методов для выполнения дополнительной логики.

Согласно официальной документации, Odoo предоставляет три типа наследования:

• Наследование классов (расширение)

• Наследование прототипа

• Делегирование наследования

Мы увидим каждый из них в отдельном рецепте. В этом рецепте мы увидим наследование (расширение) класса. 
Он используется для добавления новых полей или методов к существующим моделям.

Мы расширим встроенную партнерскую модель res.partner, чтобы добавить ее в вычисляемое поле с количеством 
созданных книг. Это включает добавление поля и метода к существующей модели.

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Мы будем расширять встроенную партнерскую модель. Если вы помните, мы уже унаследовали модель 
res.parnter из раздела Добавление реляционных полей в рецепт модели в этой главе. Чтобы объяснение 
было как можно более простым, мы повторно будем использовать модель res.partner в файле кода 
models/library_book.py:

1. Во-первых, мы убедимся, что обратная связь authored_book_ids находится в модели партнера, 
и добавим вычисляемое поле:

class ResPartner(models.Model):
    _inherit = 'res.partner'
    _order = 'name'
    authored_book_ids = fields.Many2many(
        'library.book', string='Authored Books')
    count_books = fields.Integer( 'Number of Authored Books',
                                compute='_compute_count_books' )

2. Затем добавьте метод, необходимый для подсчета количества книг:

# ...
from odoo import api # if not already imported
# class ResPartner(models.Model):
    # ...
    @api.depends('authored_book_ids')
    def _compute_count_books(self):
        for r in self:
            r.count_books = len(r.authored_book_ids)

Наконец, нам нужно обновить дополнительный модуль, чтобы изменения вступили в силу.

Как это работает...

Когда класс модели определяется с помощью атрибута _inherit, он добавляет модификации к 
унаследованной модели, а не заменяет ее.

Это означает, что поля, определенные в наследующем классе, добавляются или изменяются в 
родительской модели. На уровне базы данных ORM добавляет поля в ту же таблицу базы данных.

Поля также постепенно изменяются. Это означает, что если поле уже существует в суперклассе, 
изменяются только атрибуты, объявленные в унаследованном классе; остальные остаются такими 
же, как и в родительском классе.

Методы, определенные в наследующем классе, заменяют методы в родительском классе. 
Если вы не вызовете родительский метод с помощью супервызова, в этом случае родительская 
версия метода не будет выполнена, и мы потеряем функции. Итак, всякий раз, когда вы 
добавляете новую логику, наследуя существующие методы, вы должны включать оператор с super 
для вызова его версии в родительском классе. Более подробно это обсуждается в главе 5, 
Базовая разработка на стороне сервера.

Этот рецепт добавит новые поля к существующей модели. Если вы также хотите добавить эти 
новые поля к существующим представлениям (пользовательскому интерфейсу), обратитесь к 
разделу «Изменение существующих представлений - рецепт наследования представлений» в 
главе 9, Внутренние представления.

Копировать определение модели с помощью наследования

Мы видели наследование (расширение) классов в предыдущем рецепте. Теперь мы увидим наследование 
прототипа, которое используется для копирования всего определения существующей модели.
В этом рецепте мы сделаем копию модели library.book.

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Наследование прототипа выполняется с использованием атрибутов класса _name и _inherit 
одновременно. Выполните следующие шаги, чтобы создать копию модели library.book:

1. Добавьте новый файл с именем library_book_copy.py в каталог /my_library/models/.

2. Добавьте следующее содержимое в файл library_book_copy.py:

from odoo import models, fields, api
class LibraryBookCopy(models.Model):
    _name = "library.book.copy"
    _inherit = "library.book"
    _description = "Library Book's Copy"

3. Импортируйте новую ссылку на файл в файл /my_library/models/__init__.py.
После изменений ваш файл __init__.py будет выглядеть так:

Наконец, нам нужно обновить дополнительный модуль, чтобы изменения вступили в силу. 
Чтобы проверить определение новой модели, перейдите в Настройки | Технические | 
Структура базы данных | Меню моделей. Здесь вы увидите новую запись для модели 
library.book.copy.

Кончик

Чтобы увидеть меню и представления для новой модели, необходимо добавить определение 
представлений и меню XML. Чтобы узнать больше о представлениях и меню, обратитесь к 
рецепту Добавление элементов меню и представлений в главе 3, Создание дополнительных 
модулей Odoo.

Как это работает...

Используя одновременно _name с атрибутом класса _inherit, вы можете скопировать 
определение модели. Когда вы используете оба атрибута в модели, Odoo скопирует 
определение модели _inherit и создаст новую модель с атрибутом _name.

В нашем примере Odoo скопирует определение модели library.book и создаст новую модель 
library.book.copy. Новая модель library.book.copy имеет собственную таблицу базы данных 
со своими собственными данными, которые полностью независимы от библиотека.
книга родительской модели. Поскольку он по-прежнему наследуется от партнерской модели, 
любые последующие изменения в нем также повлияют на новую модель.

Наследование прототипа копирует все свойства родительского класса. Он копирует поля, 
атрибуты и методы. Если вы хотите изменить их в дочернем классе, вы можете просто 
сделать это, добавив новое определение в дочерний класс. Например, модель library.book 
имеет метод _name_get. Если вы хотите использовать другую версию _name_get в дочернем 
элементе, вам необходимо переопределить метод в модели library.book.copy.

Предупреждение

Наследование прототипа не работает, если вы используете одно и то же имя модели 
в атрибутах _inherit и _name. Если вы используете одно и то же имя модели в 
атрибутах _inherit и _name, оно будет вести себя как обычное наследование 
расширений.

Есть больше…

В официальной документации это называется наследованием прототипа, но на практике 
используется редко. Причина этого в том, что наследование делегирования обычно 
отвечает на эту потребность более эффективным способом, без необходимости дублировать 
структуры данных. Для получения дополнительной информации об этом вы можете обратиться 
к следующему рецепту, Использование наследования с делегированием для копирования 
функций в другую модель.

Использование наследования с делегированием для копирования функций в другую модель

Третий тип наследования - наследование с делегированием. Вместо _inherit он использует 
атрибут класса _inherits. Бывают случаи, когда вместо изменения существующей модели 
мы хотим создать новую модель на основе существующей, чтобы использовать уже имеющиеся 
в ней функции. Мы можем скопировать определения модели с наследованием прототипа, но 
это создаст повторяющиеся структуры данных. Если вы хотите скопировать определения модели 
без дублирования структур данных, то ответ заключается в наследовании делегирования Odoo, 
которое использует атрибут модели _inherits (обратите внимание на дополнительные s).

Традиционное наследование сильно отличается от концепции объектно-ориентированного 
программирования. Наследование с делегированием, в свою очередь, аналогично тому, 
что новая модель может быть создана для включения функций из родительской модели. 
Он также поддерживает полиморфное наследование, при котором мы наследуем от двух 
или более других моделей.

У нас есть библиотека с книгами. Пора и в нашу библиотеку пополниться. Для члена 
библиотеки нам нужны все идентификационные и адресные данные, которые есть в 
партнерской модели, и мы также хотим, чтобы в ней сохранялась некоторая информация, 
относящаяся к членству: дата начала, дата прекращения и номер карты.

Добавление этих полей в партнерскую модель - не лучшее решение, поскольку они не 
будут использоваться для партнеров, которые не являются участниками. Было бы здорово 
расширить партнерскую модель до новой модели с некоторыми дополнительными полями.

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Новая модель члена библиотеки должна быть в отдельном файле кода Python, но чтобы 
объяснение было как можно более простым, мы будем повторно использовать файл 
models/library_book.py:

1. Добавьте новую модель, унаследованную от res.partner:

class LibraryMember(models.Model):
    _name = 'library.member'
    _inherits = {'res.partner': 'partner_id'}
    partner_id = fields.Many2one(
        'res.partner',
        ondelete='cascade')

2. Затем мы добавим поля, относящиеся к членам библиотеки:

# class LibraryMember(models.Model):
    # ...
    date_start = fields.Date('Member Since')
    date_end = fields.Date('Termination Date')
    member_number = fields.Char()
    date_of_birth = fields.Date('Date of birth')

Теперь мы должны обновить дополнительный модуль, чтобы изменения вступили в силу.

Как это работает...

Атрибут _inherits model устанавливает родительские модели, от которых мы хотим наследовать. 
В данном случае у нас только один - res.partner. Его значение представляет собой словарь 
«ключ-значение», где ключи - это унаследованные модели, а значения - это имена полей, 
которые использовались для связи с ними. Это поля Many2one, которые мы также должны 
определить в модели. В нашем примере partner_id - это поле, которое будет использоваться 
для связи с родительской моделью Partner.

Чтобы лучше понять, как это работает, давайте посмотрим, что происходит на уровне базы данных, 
когда мы создаем нового члена:

• В таблице res_partner создается новая запись.

• В таблице library_member создается новая запись.

• В поле partner_id таблицы library_member устанавливается идентификатор записи res_partner, 
созданной для нее.

Запись участника автоматически связывается с новой записью партнера. Это просто отношение 
«многие к одному», но механизм делегирования добавляет некоторую магию, так что поля 
партнера отображаются так, как будто они принадлежат записи члена, и новая запись партнера 
также автоматически создается с новым членом.

Итак, что произойдет, если вы удалите партнерскую запись, которая также является участником? 
Вы решаете, выбирая значение ondelete для поля отношения. Для partner_id мы использовали 
cascade. Это означает, что при удалении партнера будет удален и член-корреспондент. 
Мы могли бы использовать более консервативную настройку, ограничить, чтобы запретить 
удаление партнера, пока у него есть связанный член. В этом случае будет работать только 
удаление участника.

Важно отметить, что наследование делегирования работает только для полей, а не для методов. 
Итак, если у партнерской модели есть метод do_something(), модель членов не наследует 
его автоматически.

Есть больше...

Для этого делегирования наследования есть ярлык. Вместо создания словаря _inherits вы 
можете использовать атрибут delegate = True в определении поля Many2one.
Это будет работать точно так же, как опция _inherits. Главное преимущество в том, 
что это проще. В данном примере мы выполнили то же делегирование наследования, что и в 
предыдущем, но в этом случае вместо создания словаря _inherits мы использовали параметр 
delegate = True в поле partner_id:

class LibraryMember(models.Model):
    _name = 'library.member'
    partner_id = fields.Many2one('res.partner',
                                ondelete='cascade', delegate=True)
    date_start = fields.Date('Member Since')
    date_end = fields.Date('Termination Date')
    member_number = fields.Char()
    date_of_birth = fields.Date('Date of birth')

