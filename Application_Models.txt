Модели приложений

Рецепты в этой главе станут небольшими дополнениями к существующему дополнительному 
модулю. В предыдущей главе мы зарегистрировали наш дополнительный модуль в экземпляре 
Odoo. В этой главе мы глубоко погрузимся в модуль базы данных. Мы добавим новую модель 
(таблицу базы данных), новые поля и ограничения. Мы также рассмотрим использование 
наследования в Odoo. Мы будем использовать модуль, который мы создали в рецептах 
в главе 3, Создание дополнительных модулей Odoo.

В этой главе мы рассмотрим следующие рецепты:

• Определение представления модели и порядка

• Добавление полей данных в модель

• Использование поля с плавающей запятой с настраиваемой точностью

• Добавление денежного поля в модель

• Добавление реляционных полей в модель

• Добавление иерархии в модель

• Добавление проверок ограничений в модель

• Добавление вычисляемых полей в модель

• Отображение связанных полей, хранящихся в других моделях

• Добавление динамических отношений с использованием справочных полей

• Добавление функций в модель с помощью наследования

• Использование абстрактных моделей для многоразовых функций модели.

• Использование наследования делегирования для копирования функций в другую модель

Технические требования

Чтобы следовать примерам в этой главе, у вас должен быть модуль, который мы создали 
в главе 3 «Создание дополнительных модулей Odoo», и этот модуль должен быть готов к использованию.
Весь код, используемый в этой главе, можно загрузить из репозитория GitHub по адресу 
https://github.com/PacktPublishing/Odoo-14-Development-Cookbook-Fourth-Edition/tree/master/Chapter04.

Определение представления модели и порядка

У моделей есть структурные атрибуты, определяющие их поведение. Они имеют префикс подчеркивания. 
Самый важный атрибут модели - _name, так как он определяет внутренний глобальный идентификатор. 
Внутри Odoo использует этот атрибут _name для создания таблицы базы данных. Например, если вы 
укажете _name = "library.book", ORM Odoo создаст таблицу library_book в базе данных. Вот 
почему атрибут _name должен быть уникальным в Odoo.

Есть два других атрибута, которые мы можем использовать в модели:

• _rac_name используется для установки поля, которое используется в качестве представления 
или заголовка для записей.

• Другой - _order, который используется для установки порядка представления записей.

Готовиться

Этот рецепт предполагает, что у вас есть готовый экземпляр с модулем my_library, как описано 
в главе 3, Создание дополнительных модулей Odoo.

Как это сделать...

Экземпляр my_library уже должен содержать файл Python с именем models/library_book.py, 
который определяет базовую модель. Мы отредактируем его, добавив новый атрибут уровня 
класса после _name:

1. Чтобы добавить к модели удобный заголовок, добавьте следующий код:

_description = 'Library Book'

2. Чтобы сначала отсортировать записи (от самых новых до самых старых, а затем по 
заголовку), добавьте следующий код:

_order = 'date_release desc, name'

3. To use the short_name field as the record representation, add the following code:

_rec_name = 'short_name'
short_name = fields.Char('Short Title', required=True)

4. Добавьте поле short_name в представление формы, чтобы оно могло отображать новое поле в представлении:

<field name="short_name"/>

Когда мы закончим, наш файл library_book.py должен выглядеть следующим образом:

from odoo import models, fields
class LibraryBook(models.Model):
    _name = 'library.book'
    _description = 'Library Book'
    _order = 'date_release desc, name'
    _rec_name = 'short_name'
    name = fields.Char('Title', required=True)
    short_name = fields.Char('Short Title', required=True)
    date_release = fields.Date('Release Date')
    author_ids = fields.Many2many('res.partner', string='Authors')

Ваше представление <form> в файле library_book.xml будет выглядеть следующим образом:

<form>
    <group>
        <group>
            <field name="name"/>
            <field name="author_ids" widget="many2many_tags"/>
        </group>
        <group>
            <field name="short_name"/>
            <field name="date_release"/>
        </group>
    </group>
</form>

Затем мы должны обновить модуль, чтобы активировать эти изменения в Odoo. Чтобы обновить 
модуль, вы можете открыть меню приложений, найти модуль my_library, а затем обновить 
модуль с помощью раскрывающегося списка, как показано на следующем снимке экрана:

Figure 4.1 – Option to update the module

Кроме того, вы также можете использовать команду -u my_library в командной строке.

Как это работает...

На первом этапе к определению модели добавляется более удобный заголовок. Это не 
обязательно, но может использоваться некоторыми надстройками. Например, он используется 
функцией отслеживания в дополнительном модуле почты для текста уведомления при создании 
новой записи. Дополнительные сведения см. В главе 23 «Управление электронной почтой в Odoo». 
Если вы не используете _description для своей модели, в этом случае Odoo покажет 
предупреждение в журналах.

По умолчанию Odoo упорядочивает записи, используя значение внутреннего идентификатора 
(автоматически сгенерированный первичный ключ). Однако это можно изменить, чтобы мы могли 
использовать поля по нашему выбору, предоставив атрибут _order со строкой, содержащей список 
имен полей, разделенных запятыми.
За именем поля может следовать ключевое слово desc, чтобы отсортировать его в порядке убывания.

Важная заметка

Могут использоваться только поля, хранящиеся в базе данных. Не хранимые вычисляемые поля 
нельзя использовать для сортировки записей.

Синтаксис строки _order аналогичен предложениям SQL ORDER BY, хотя и урезан. Например, 
специальные предложения, такие как NULLS FIRST, не допускаются.

Записи модели используют представление, когда на них ссылаются другие записи. Например, 
поле user_id со значением 1 представляет пользователя-администратора. При отображении в 
виде формы Odoo будет отображать имя пользователя, а не идентификатор базы данных. Короче 
говоря, _rec_name - это отображаемое имя записи, используемое графическим интерфейсом Odoo 
для представления этой записи. По умолчанию используется поле имени. Фактически, это 
значение по умолчанию для атрибута _rec_ name, поэтому в наших моделях удобно иметь поле 
имени. В нашем примере модель library.book имеет поле имени, поэтому по умолчанию Odoo 
будет использовать его как отображаемое имя. Мы хотим изменить это поведение на шаге 3; 
мы использовали short_name в качестве _rec_name. После этого отображаемое имя модели 
library.book изменится с имени на short_name, и графический интерфейс Odoo будет 
использовать значение short_name для представления записи.

Предупреждение

Если в вашей модели нет поля имени, и в этом случае вы не указали _rec_ name, ваше 
отображаемое имя будет представлять собой комбинацию имени модели и идентификатора 
записи, например: (library.book, 1).

Поскольку мы добавили в модель новое поле short_name, Odoo ORM добавит новый столбец 
в таблицу базы данных, но не будет отображать это поле в представлении. Для этого 
необходимо добавить это поле в представление формы. На шаге 4 мы добавили поле 
short_name в представление формы.

Есть больше...

Представление записи доступно в вычисляемом поле magic display_name и было 
автоматически добавлено во все модели, начиная с версии 8.0. Его значения 
генерируются с использованием метода модели name_get(), который уже существовал 
в предыдущих версиях Odoo.

Реализация по умолчанию name_get() использует атрибут _rec_name, чтобы найти, 
какое поле содержит данные, которые используются для генерации отображаемого имени. 
Если вам нужна собственная реализация отображаемого имени, вы можете переопределить 
логику name_get(), чтобы сгенерировать настраиваемое отображаемое имя. Метод должен 
возвращать список кортежей с двумя элементами: идентификатором записи и строковым 
представлением записи в Юникоде.

Например, чтобы иметь название и дату его выпуска в представлении, например 
Моби Дик (1851-10-18), мы можем определить следующее:

Взгляните на следующий пример. Это добавит дату выпуска в название записи:

def name_get(self):
    result = []
    for record in self:
        rec_name = "%s (%s)" % (record.name, record.date_release)
        result.append((record.id, rec_name))
    return result

После добавления предыдущего кода ваша запись display_name будет обновлена. 
Предположим, у вас есть запись с именем Odoo Cookbook и датой выпуска 19-04-2019, 
тогда предыдущий метод name_get() сгенерирует имя, такое как Odoo Cookbook (19-04-2019).

Добавление полей данных в модель

Модели предназначены для хранения данных, и эти данные структурированы по полям. 
Здесь вы узнаете о нескольких типах данных, которые могут храниться в полях, и о том, 
как добавить их в модель.

Готовиться

Этот рецепт предполагает, что у вас есть готовый экземпляр с доступным дополнительным 
модулем my_library, как описано в главе 3, Создание дополнительных модулей Odoo.

Как это сделать...

В дополнительном модуле my_library уже должен быть файл models/library_book.py, 
определяющий базовую модель. Мы отредактируем его, чтобы добавить новые поля:

1. Используйте минимальный синтаксис для добавления полей в модель библиотечных книг:

from odoo import models, fields
class LibraryBook(models.Model):
    # ...
    short_name = fields.Char('Short Title')
    notes = fields.Text('Internal Notes')
    state = fields.Selection(
        [('draft', 'Not Available'),
        ('available', 'Available'),
        ('lost', 'Lost')],
        'State')
    description = fields.Html('Description')
    cover = fields.Binary('Book Cover')
    out_of_print = fields.Boolean('Out of Print?')
    date_release = fields.Date('Release Date')
    date_updated = fields.Datetime('Last Updated')
    pages = fields.Integer('Number of Pages')
    reader_rating = fields.Float(
        'Reader Average Rating',
        digits=(14, 4), # Optional precision decimals,
    )

2. Мы добавили в модель новые поля. Нам все еще нужно добавить эти поля в представление 
формы, чтобы отразить эти изменения в пользовательском интерфейсе. Обратитесь к следующему 
коду, чтобы добавить поля в представление формы:

<form>
    <group>
        <group>
            <field name="name"/>
            <field name="author_ids" widget="many2many_tags"/>
            <field name="state"/>
            <field name="pages"/>
            <field name="notes"/>
        </group>
        <group>
            <field name="short_name"/>
            <field name="date_release"/>
            <field name="date_updated"/>
            <field name="cover" widget="image" class="oe_avatar"/>
            <field name="reader_rating"/>
        </group>
    </group>
    <group>
        <field name="description"/>
    </group>
</form>

Обновление модуля сделает эти изменения эффективными в модели Odoo.

Взгляните на следующие образцы различных полей. Здесь мы использовали разные 
атрибуты для разных типов полей. Это даст вам лучшее представление об объявлении поля:

short_name = fields.Char('Short Title',translate=True, index=True)
state = fields.Selection(
    [('draft', 'Not Available'),
        ('available', 'Available'),
        ('lost', 'Lost')],
    'State', default="draft")
description = fields.Html('Description', sanitize=True, strip_style=False)
pages = fields.Integer('Number of Pages',
    groups='base.group_user',
    states={'lost': [('readonly', True)]},
    help='Total book page count', company_dependent=False)

Как это работает...

Поля добавляются к моделям путем определения атрибута в их классах Python. Доступны 
следующие нереляционные типы полей:

• Char используется для строковых значений.

• Текст используется для многострочных строковых значений.

• Выбор используется для списков выбора. Это список значений и пар описания.
Выбранное значение сохраняется в базе данных и может быть строкой или целым числом. 
Описание переводится автоматически.

Важная заметка

В полях типа Selection вы можете использовать целочисленные ключи, но вы должны знать, 
что Odoo интерпретирует 0 как не установленный внутри, и не будет отображать описание, 
если сохраненное значение равно нулю. Это может случиться, поэтому вам нужно будет это учитывать.

• Html похож на текстовое поле, но предполагается, что он будет хранить богатый текст в формате HTML.

• Двоичные поля хранят двоичные файлы, такие как изображения или документы.

• Boolean хранит значения True / False.

• Дата хранит значения даты. Они хранятся в базе данных как даты. ORM обрабатывает их в виде 
объектов даты Python. Вы можете использовать fields.Date.today (), чтобы установить текущую 
дату как значение по умолчанию в поле даты.

• Datetime используется для значений datetime. Они хранятся в базе данных в наивном 
datetime по времени UTC. ORM обрабатывает их в виде объектов даты и времени Python. 
Вы можете использовать fields.Date.now (), чтобы установить текущее время в качестве 
значения по умолчанию в поле datetime.

• Целочисленные поля не нуждаются в дополнительных пояснениях.

• Поля с плавающей запятой хранят числовые значения. Их точность при желании может 
быть определена с помощью общего количества цифр и пар десятичных цифр.

• В денежном выражении может храниться сумма в определенной валюте. Это также будет 
объяснено в разделе «Добавление денежного поля» в этой главе.

Первый шаг этого рецепта показывает минимальный синтаксис, который нужно добавить 
к каждому типу поля. Определения полей можно расширить, добавив другие необязательные 
атрибуты, как показано на шаге 2.

Вот объяснение использованных атрибутов поля:

• строка - заголовок поля и используется в метках представления пользовательского интерфейса. 
Это необязательно. Если не установлен, метка будет производиться от имени поля путем добавления 
регистра заголовка и замены подчеркивания пробелами.

• translate, если установлено значение True, делает поле переводимым. Он может иметь 
различное значение в зависимости от языка пользовательского интерфейса.

• default - значение по умолчанию. Это также может быть функция, которая используется 
для вычисления значения по умолчанию; например, default = _compute_default, где _compute_default - 
это метод, который был определен в модели до определения поля.

• help - это текст объяснения, который отображается во всплывающих подсказках пользовательского 
интерфейса.

• groups делает поле доступным только для некоторых групп безопасности. Это строка, 
содержащая разделенный запятыми список идентификаторов XML для групп безопасности. 
Более подробно это рассматривается в главе 10 «Безопасный доступ».

• States позволяет пользовательскому интерфейсу динамически устанавливать значения 
атрибутов readonly, required и invisible в зависимости от значения поля состояния.
Следовательно, для этого требуется, чтобы поле состояния существовало и использовалось 
в представлении формы (даже если оно невидимо). Имя атрибута состояния жестко запрограммировано 
в Odoo и не может быть изменено.

• copy указывает, копируется ли значение поля при дублировании записи. По умолчанию это 
True для нереляционных полей и полей Many2one и False для One2many и вычисляемых полей.

• index, если установлено значение True, создает индекс базы данных для поля, что иногда 
позволяет ускорить поиск. Он заменяет устаревший атрибут select = 1.

• Флаг readonly делает поле доступным только для чтения по умолчанию в пользовательском интерфейсе.

• Наличие флага required делает поле обязательным по умолчанию в пользовательском интерфейсе.
Упомянутые здесь различные белые списки определены в odoo/tools/mail.py.

• Флаг company_dependent заставляет поле хранить разные значения для каждой компании. Он 
заменяет устаревший тип поля Property.

• group_operator - агрегатная функция, используемая для отображения результатов в 
режиме группировки. Возможные значения для этого атрибута включают count, count_distinct, 
array_agg, bool_and, bool_or, max, min, avg и sum. Типы полей Integer, Float и Monetary 
имеют для этого атрибута значение по умолчанию sum.

• Флаг очистки используется полями HTML и удаляет его содержимое из потенциально 
небезопасных тегов. При этом выполняется глобальная очистка ввода.

Если вам нужен более точный контроль при очистке HTML, вы можете использовать еще 
несколько атрибутов, которые работают, только если включена очистка:

• sanitize_tags = True, чтобы удалить теги, не входящие в белый список (это значение по умолчанию)

• sanitize_attributes = True, чтобы удалить атрибуты тегов, которые не являются частью белого списка.

• sanitize_style = True, чтобы удалить свойства стиля, не входящие в белый список.

• strip_style = True, чтобы удалить все элементы стиля

• strip_class = True, чтобы удалить атрибуты класса

Наконец, мы обновили вид формы в соответствии с недавно добавленными полями в модели. 
Мы разместили здесь теги <field> произвольным образом, но вы можете разместить их где угодно. 
Представления форм более подробно описаны в главе 9, Представления серверной части.

Есть больше...

Поле Selection также принимает ссылку на функцию в качестве атрибута выбора вместо списка. 
Это позволяет динамически генерировать списки опций. Вы можете найти пример, относящийся 
к этому, в рецепте Добавление динамических отношений с использованием ссылочных полей в 
этой главе, где также используется атрибут выбора.

Объекты полей Date и Datetime предоставляют несколько удобных служебных методов.

Для Date у нас есть следующее:

• fields.Date.to_date (string_value) преобразует строку в объект даты.

• fields.Date.to_string (date_value) преобразует объект Date Python в строку.

• fields.Date.today () возвращает текущий день в строковом формате. Это подходит для 
значений по умолчанию.

• fields.Date.context_today (record, timestamp) возвращает день метки времени 
(или текущий день, если метка времени не указана) в строковом формате в соответствии 
с часовым поясом контекста записи (или набора записей).

Для Datetime у нас есть следующее:

• fields.Datetime.to_datetime (string_value) преобразует строку в объект datetime.

• fields.Datetime.to_string (datetime_value) преобразует объект datetime в строку.

• fields.Datetime.now () возвращает текущий день и время в строковом формате.
Это подходит для значений по умолчанию.

• fields.Datetime.context_timestamp (record, timestamp) преобразует объект datetime с 
меткой времени в объект datetime с учетом часового пояса, используя часовой пояс в 
контексте записи. Это не подходит для значений по умолчанию, но может использоваться в 
случаях, когда вы отправляете данные во внешнюю систему.

Помимо основных полей, у нас также есть реляционные поля: Many2one, One2many и Many2many. 
Они объясняются в разделе «Добавление реляционных полей в рецепт модели» в этой главе.

Также возможно иметь поля с автоматически вычисляемыми значениями, определяя 
функцию вычисления с атрибутом вычисляемого поля. Это объясняется в разделе 
«Добавление вычисленных полей в рецепт модели».

Некоторые поля добавляются по умолчанию в моделях Odoo, поэтому мы не должны использовать 
эти имена для наших полей. Это поле id для автоматически сгенерированного идентификатора 
записи и несколько полей журнала аудита, а именно:

• create_date - отметка времени создания записи.

• create_uid - пользователь, создавший запись.

• write_date - это последнее записанное изменение метки времени.

• write_uid - это пользователь, который последним редактировал запись.

Автоматическое создание этих полей журнала можно отключить, установив атрибут модели _log_access = False.

Еще один специальный столбец, который можно добавить в модель, активен. Это должно быть 
логическое поле, позволяющее пользователям отмечать записи как неактивные. Он используется 
для включения функции архивирования / разархивирования записей. Его определение таково:

active = fields.Boolean('Active', default=True)

По умолчанию видны только записи с активным значением True. Чтобы получить их, нам нужно 
использовать фильтр домена с [('active', '=', False)]. В качестве альтернативы, если 
значение active_test: False добавлено в контекст среды, ORM не будет отфильтровывать неактивные записи.

В некоторых случаях вы не сможете изменить контекст, чтобы получить как активные, 
так и неактивные записи. В этом случае вы можете использовать домен 
['|', ('active', = ', True), (' active ',' = ', False)].

Осторожность

[('active', 'in' (True, False))] работает не так, как вы могли ожидать. 
Odoo явно ищет предложение ('active', '=', False) в домене. По умолчанию поиск 
будет ограничен только активными записями.

Использование поля с плавающей запятой с настраиваемой точностью

При использовании полей с плавающей запятой мы можем позволить конечному пользователю 
настроить десятичную точность, которая будет использоваться. В этом рецепте мы добавим 
поле «Стоимость» в модель «Библиотечные книги» с настраиваемой пользователем точностью 
до десятичной дроби.

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Выполните следующие шаги, чтобы применить динамическую десятичную точность к полю cost_price модели:

1. Активируйте режим разработчика по ссылке в меню «Настройки» (см. Рецепт 
«Активация инструментов разработчика Odoo» в главе 1, «Установка среды разработки Odoo»). 
Это активирует Настройки | Техническое меню.

2. Доступ к конфигурациям десятичной точности. Для этого откройте верхнее меню «Настройки» 
и выберите «Технические | Структура базы данных | Десятичная точность. Мы должны увидеть 
список текущих настроек.

3. Добавьте новую конфигурацию, установив для использования значение «Книжная цена» и 
выбрав точность в цифрах:

Figure 4.2 – Creating new decimal precision

4. Чтобы добавить поле модели с использованием этого параметра точности десятичной дроби, 
отредактируйте файл models/library_book.py, добавив следующий код:

class LibraryBook(models.Model):
    cost_price = fields.Float(
                            'Book Cost', digits='Book Price')

Кончик

Каждый раз, когда вы добавляете новые поля в модели, вам нужно будет добавить их в представления, 
чтобы получить к ним доступ из пользовательского интерфейса. В предыдущем примере мы добавили 
поле cost_price. Чтобы увидеть это в представлении формы, вам нужно добавить его с помощью 
<field name="cost_price"/>.

Как это работает...

Когда вы добавляете строковое значение к атрибуту digits поля, Odoo ищет эту строку в поле 
Usage модели десятичной точности и возвращает кортеж с точностью до 16 цифр и количеством 
десятичных знаков, которые были определены в конфигурации. Использование определения поля 
вместо его жесткого программирования позволяет конечному пользователю настроить его в 
соответствии со своими потребностями.

Кончик

Если вы используете версию старше v13, вам потребуется дополнительная работа, чтобы 
использовать атрибут digits в полях с плавающей запятой. В более старых версиях десятичная 
точность была доступна в отдельном модуле decimal_precision. Чтобы включить настраиваемую 
десятичную точность в вашем поле, вы должны использовать метод get_precision() модуля 
decimal_precision, например: cost_price = fields.Float ('Book Cost', 
digits = dp.get_precision ('Book Price')).

Добавление денежного поля в модель

Odoo имеет специальную поддержку денежных значений, связанных с валютой. Давайте посмотрим, 
как мы можем использовать это в модели.

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Денежное поле нуждается в дополнительном поле валюты для хранения валюты сумм.

В my_library уже есть models / library_book.py, которые определяют базовую модель.
Мы отредактируем это, чтобы добавить обязательные поля:

1. Добавьте поле для хранения валюты, которая будет использоваться:

class LibraryBook(models.Model):
    # ...
    currency_id = fields.Many2one(
                                'res.currency', string='Currency')

2. Добавьте денежное поле для хранения суммы:

class LibraryBook(models.Model):
    # ...
    retail_price = fields.Monetary(
        'Retail Price',
        # optional: currency_field='currency_id',
        )

Теперь обновите дополнительный модуль, и в модели должны появиться новые поля.
Они не будут видны в представлениях, пока не будут добавлены к ним, но мы можем подтвердить 
их добавление, проверив поля модели в 
Настройках | Технические | Структура базы данных | Модели в режиме разработчика.

После добавления их в представление формы оно будет выглядеть следующим образом:

Figure 4.3 – Currency symbol in the monetary field

Как это работает...

Денежные поля похожи на поля с плавающей запятой, но Odoo может правильно представлять их 
в пользовательском интерфейсе, поскольку он знает, какая у них валюта, через второе поле.
Ожидается, что это поле валюты будет называться currency_id, но мы можем использовать любое 
имя поля, которое нам нравится, если оно указано с помощью необязательного параметра currency_field.

Кончик

Вы можете опустить атрибут currency_field в денежном поле, если вы храните информацию о 
валюте в поле с именем currency_id.

Это очень полезно, когда вам нужно вести суммы в разных валютах в одной записи. Например, 
если мы хотим включить валюту заказа на продажу и валюту компании, вы можете настроить два 
поля как поля. Много2one (res.currency) и использовать первое для первой суммы, а другое - 
для второй суммы.

Возможно, вы захотите узнать, что десятичная точность для суммы взята из определения 
валюты (поле десятичной точности модели red.currency).

Добавление реляционных полей в модель

Отношения между моделями Odoo представлены реляционными полями. Есть три разных типа отношений:

• многие к одному, обычно сокращенно m2o

• «один ко многим», обычно сокращенно o2m

• многие ко многим, обычно сокращенно m2m

Глядя на пример библиотечных книг, мы видим, что у каждой книги может быть только один издатель, 
поэтому между книгами и издателями может быть связь «многие к одному».

Однако у каждого издателя может быть много книг. Итак, предыдущее отношение «многие к одному» 
подразумевает обратное отношение «один ко многим».

Наконец, есть случаи, когда мы можем иметь отношение «многие ко многим». В нашем примере у 
каждой книги может быть несколько (много) авторов. И наоборот, каждый автор мог написать 
много книг. Если посмотреть на это с любой стороны, это отношение «многие ко многим».

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Odoo использует партнерскую модель res.partner для представления людей, организаций и 
адресов. Мы должны использовать его для авторов и издателей. Мы отредактируем файл 
models/library_book.py, чтобы добавить эти поля:

1. Добавьте поле "многие к одному" для издателя книги в Библиотечные книги:

class LibraryBook(models.Model):
    # ...
    publisher_id = fields.Many2one(
        'res.partner', string='Publisher',
        # optional:
        ondelete='set null',
        context={},
        domain=[],
        )

2. Чтобы добавить поле «один ко многим» для книг издателя, нам необходимо расширить 
партнерскую модель. Для простоты мы добавим это в тот же файл Python:

class ResPartner(models.Model):
    _inherit = 'res.partner'
    published_book_ids = fields.One2many(
                                    'library.book', 'publisher_id',
                                    string='Published Books')

Атрибут _inherit, который мы здесь используем, предназначен для наследования 
существующей модели. Это будет объяснено в разделе «Добавление элементов в модель 
с использованием рецепта наследования» далее в этой главе.

3. Мы уже создали отношение «многие ко многим» между книгами и авторами, 
но давайте вернемся к нему:

class LibraryBook(models.Model):
    # ...
    author_ids = fields.Many2many(
                    'res.partner', string='Authors')


4. То же отношение, но от авторов к книгам, следует добавить к партнерской модели:

class ResPartner(models.Model):
    # ...
    authored_book_ids = fields.Many2many(
        'library.book',
        string='Authored Books',
        # relation='library_book_res_partner_rel' #optional
        )

Теперь обновите дополнительный модуль, и в модели должны появиться новые поля.
Они не будут видны в представлениях, пока не будут добавлены к ним, но мы можем подтвердить 
их добавление, проверив поля модели в 
Настройках | Технические | Структура базы данных | Модели в режиме разработчика.

Как это работает...

Поля «многие к одному» добавляют столбец в таблицу базы данных модели, в которой хранится 
идентификатор базы данных связанной записи. На уровне базы данных также будет создано 
ограничение внешнего ключа, гарантирующее, что сохраненные идентификаторы являются 
действительной ссылкой на запись в связанной таблице.
Для этих полей отношения не создается индекс базы данных, но это можно сделать, 
добавив атрибут index = True.

Мы видим, что есть еще четыре атрибута, которые мы можем использовать для полей типа 
"многие к одному". Атрибут ondelete определяет, что происходит при удалении связанной 
записи. Например, что происходит с книгами, когда их запись об издателе удаляется? По 
умолчанию установлено значение «set null», при котором в поле устанавливается пустое 
значение. Это также может быть «ограничить», что препятствует удалению связанной записи, 
или «каскад», при котором связанная запись также удаляется.

Последние два (контекст и домен) также действительны для других реляционных полей. 
Они в основном значимы на стороне клиента, а на уровне модели действуют как значения 
по умолчанию, которые будут использоваться в представлениях на стороне клиента:

• context добавляет переменные в контекст клиента при щелчке по полю в представлении 
связанной записи. Мы можем, например, использовать его для установки значений по умолчанию 
для новых записей, которые создаются с помощью этого представления.

• домен - это фильтр поиска, который используется для ограничения списка доступных 
связанных записей.

И контекст, и домен более подробно описаны в главе 9, Backend Views.

Поля «один ко многим» являются противоположностью отношений «многие к одному», 
и хотя они добавляются в модели так же, как и другие поля, они не имеют реального 
представления в базе данных. Вместо этого они представляют собой программные ярлыки, 
и они позволяют представлениям представлять эти списки связанных записей. Это означает, 
что для полей типа «один ко многим» требуется поле «многие к одному» в эталонной модели. 
В нашем примере мы добавили поле «один ко многим», унаследовав партнерскую модель. Мы 
подробно рассмотрим наследование модели в разделе «Добавление функций в модель с использованием 
рецепта наследования» в этой главе. В нашем примере поле «один-ко-многим» published_book_ids 
имеет ссылку на поле publisher_id модели library.book.

Отношения «многие ко многим» также не добавляют столбцы в таблицы для моделей. Этот 
тип отношения представлен в базе данных с помощью промежуточной таблицы отношений 
с двумя столбцами для хранения двух связанных идентификаторов. Добавление нового 
отношения между книгой и автором создает новую запись в таблице отношений с идентификатором 
книги и идентификатором автора.

Odoo автоматически обрабатывает создание этой таблицы отношений. Имя таблицы отношений 
по умолчанию строится с использованием имен двух связанных моделей, отсортированных по 
алфавиту, а также суффикса _rel. Однако мы можем переопределить это, используя атрибут отношения.

Следует иметь в виду, что имена двух таблиц достаточно велики, чтобы автоматически 
сгенерированные идентификаторы базы данных превышали лимит PostgreSQL в 63 символа. 
Как правило, если имена двух связанных таблиц превышают 23 символа, вы должны использовать 
атрибут отношения, чтобы установить более короткое имя. В следующем разделе мы более подробно 
остановимся на этом.

Есть больше...

Поля Many2one поддерживают дополнительный атрибут auto_join. Это флаг, который позволяет 
ORM использовать SQL-соединения в этом поле. Благодаря этому он обходит обычный контроль ORM, 
такой как контроль доступа пользователей и правила доступа к записям. В определенных случаях 
он может решить проблемы с производительностью, но рекомендуется избегать его использования.

Мы рассмотрели кратчайший способ определения реляционных полей. Давайте посмотрим 
на атрибуты, характерные для этого типа поля.

Атрибуты поля One2many следующие:

• comodel_name: это идентификатор целевой модели, обязательный для всех реляционных 
полей, но его можно определять позиционно без ключевого слова.

• inverse_name: это применимо только к One2many и является именем поля в целевой модели 
для обратного отношения Many2one.

• limit: это относится к One2many и Many2many и устанавливает необязательный предел количества 
записей для чтения, которые используются на уровне пользовательского интерфейса.

Атрибуты поля Many2many следующие:

• comodel_name: то же самое, что и для поля One2many.

• отношение: это имя, которое следует использовать для таблицы, поддерживающей отношение, заменяя 
автоматически определенное имя.

• column1: это имя поля Many2one в реляционной таблице, связанной с этой моделью.

• column2: это имя поля Many2one в реляционной таблице, связанной с comodel.

Для отношений Many2many в большинстве случаев ORM позаботится о значениях по умолчанию 
для этих атрибутов. Он даже способен обнаруживать обратные отношения Many2many, обнаруживать 
уже существующую таблицу отношений и соответствующим образом инвертировать значения column1 и column2.

Однако есть два случая, когда нам нужно вмешаться и предоставить собственные значения для этих атрибутов:

• Один из них - это случай, когда нам нужно более одного отношения Many2many между одними и теми же 
двумя моделями. Чтобы это было возможно, мы должны предоставить себе имя таблицы отношений для 
второго отношения, которое должно отличаться от первого отношения.

• Другой случай - это когда имена базы данных связанных таблиц достаточно длинные, чтобы 
автоматически созданное имя отношения превышало лимит PostgreSQL в 63 символа для имен 
объектов базы данных.

Автоматическое имя таблицы отношений - <model1> _ <model2> _rel. Однако эта таблица отношений 
также создает индекс для своего первичного ключа со следующим идентификатором:

<model1>_<model2>_rel_<model1>_id_<model2>_id_key

Этот первичный ключ также должен соответствовать ограничению в 63 символа. Таким образом, 
если объединенные имена двух таблиц превышают в общей сложности 63 символа, у вас, вероятно, 
возникнут проблемы с соблюдением ограничений, и вам нужно будет вручную установить атрибут отношения.

