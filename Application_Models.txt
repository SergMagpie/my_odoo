Модели приложений

Рецепты в этой главе станут небольшими дополнениями к существующему дополнительному 
модулю. В предыдущей главе мы зарегистрировали наш дополнительный модуль в экземпляре 
Odoo. В этой главе мы глубоко погрузимся в модуль базы данных. Мы добавим новую модель 
(таблицу базы данных), новые поля и ограничения. Мы также рассмотрим использование 
наследования в Odoo. Мы будем использовать модуль, который мы создали в рецептах 
в главе 3, Создание дополнительных модулей Odoo.

В этой главе мы рассмотрим следующие рецепты:

• Определение представления модели и порядка

• Добавление полей данных в модель

• Использование поля с плавающей запятой с настраиваемой точностью

• Добавление денежного поля в модель

• Добавление реляционных полей в модель

• Добавление иерархии в модель

• Добавление проверок ограничений в модель

• Добавление вычисляемых полей в модель

• Отображение связанных полей, хранящихся в других моделях

• Добавление динамических отношений с использованием справочных полей

• Добавление функций в модель с помощью наследования

• Использование абстрактных моделей для многоразовых функций модели

• Использование наследования делегирования для копирования функций в другую модель

Технические требования

Чтобы следовать примерам в этой главе, у вас должен быть модуль, который мы создали 
в главе 3 «Создание дополнительных модулей Odoo», и этот модуль должен быть готов к использованию.
Весь код, используемый в этой главе, можно загрузить из репозитория GitHub по адресу 
https://github.com/PacktPublishing/Odoo-14-Development-Cookbook-Fourth-Edition/tree/master/Chapter04.

Определение представления модели и порядка

У моделей есть структурные атрибуты, определяющие их поведение. Они имеют префикс подчеркивания. 
Самый важный атрибут модели - _name, так как он определяет внутренний глобальный идентификатор. 
Внутри Odoo использует этот атрибут _name для создания таблицы базы данных. Например, если вы 
укажете _name = "library.book", ORM Odoo создаст таблицу library_book в базе данных. Вот 
почему атрибут _name должен быть уникальным в Odoo.

Есть два других атрибута, которые мы можем использовать в модели:

• _rac_name используется для установки поля, которое используется в качестве представления 
или заголовка для записей.

• Другой - _order, который используется для установки порядка представления записей.

Готовиться

Этот рецепт предполагает, что у вас есть готовый экземпляр с модулем my_library, как описано 
в главе 3, Создание дополнительных модулей Odoo.

Как это сделать...

Экземпляр my_library уже должен содержать файл Python с именем models/library_book.py, 
который определяет базовую модель. Мы отредактируем его, добавив новый атрибут уровня 
класса после _name:

1. Чтобы добавить к модели удобный заголовок, добавьте следующий код:

_description = 'Library Book'

2. Чтобы сначала отсортировать записи (от самых новых до самых старых, а затем по 
заголовку), добавьте следующий код:

_order = 'date_release desc, name'

3. To use the short_name field as the record representation, add the following code:

_rec_name = 'short_name'
short_name = fields.Char('Short Title', required=True)

4. Добавьте поле short_name в представление формы, чтобы оно могло отображать новое поле в представлении:

<field name="short_name"/>

Когда мы закончим, наш файл library_book.py должен выглядеть следующим образом:

from odoo import models, fields
class LibraryBook(models.Model):
    _name = 'library.book'
    _description = 'Library Book'
    _order = 'date_release desc, name'
    _rec_name = 'short_name'
    name = fields.Char('Title', required=True)
    short_name = fields.Char('Short Title', required=True)
    date_release = fields.Date('Release Date')
    author_ids = fields.Many2many('res.partner', string='Authors')

Ваше представление <form> в файле library_book.xml будет выглядеть следующим образом:

<form>
    <group>
        <group>
            <field name="name"/>
            <field name="author_ids" widget="many2many_tags"/>
        </group>
        <group>
            <field name="short_name"/>
            <field name="date_release"/>
        </group>
    </group>
</form>

Затем мы должны обновить модуль, чтобы активировать эти изменения в Odoo. Чтобы обновить 
модуль, вы можете открыть меню приложений, найти модуль my_library, а затем обновить 
модуль с помощью раскрывающегося списка, как показано на следующем снимке экрана:

Figure 4.1 – Option to update the module

Кроме того, вы также можете использовать команду -u my_library в командной строке.

Как это работает...

На первом этапе к определению модели добавляется более удобный заголовок. Это не 
обязательно, но может использоваться некоторыми надстройками. Например, он используется 
функцией отслеживания в дополнительном модуле почты для текста уведомления при создании 
новой записи. Дополнительные сведения см. В главе 23 «Управление электронной почтой в Odoo». 
Если вы не используете _description для своей модели, в этом случае Odoo покажет 
предупреждение в журналах.

По умолчанию Odoo упорядочивает записи, используя значение внутреннего идентификатора 
(автоматически сгенерированный первичный ключ). Однако это можно изменить, чтобы мы могли 
использовать поля по нашему выбору, предоставив атрибут _order со строкой, содержащей список 
имен полей, разделенных запятыми.
За именем поля может следовать ключевое слово desc, чтобы отсортировать его в порядке убывания.

Важная заметка

Могут использоваться только поля, хранящиеся в базе данных. Не хранимые вычисляемые поля 
нельзя использовать для сортировки записей.

Синтаксис строки _order аналогичен предложениям SQL ORDER BY, хотя и урезан. Например, 
специальные предложения, такие как NULLS FIRST, не допускаются.

Записи модели используют представление, когда на них ссылаются другие записи. Например, 
поле user_id со значением 1 представляет пользователя-администратора. При отображении в 
виде формы Odoo будет отображать имя пользователя, а не идентификатор базы данных. Короче 
говоря, _rec_name - это отображаемое имя записи, используемое графическим интерфейсом Odoo 
для представления этой записи. По умолчанию используется поле имени. Фактически, это 
значение по умолчанию для атрибута _rec_ name, поэтому в наших моделях удобно иметь поле 
имени. В нашем примере модель library.book имеет поле имени, поэтому по умолчанию Odoo 
будет использовать его как отображаемое имя. Мы хотим изменить это поведение на шаге 3; 
мы использовали short_name в качестве _rec_name. После этого отображаемое имя модели 
library.book изменится с имени на short_name, и графический интерфейс Odoo будет 
использовать значение short_name для представления записи.

Предупреждение

Если в вашей модели нет поля имени, и в этом случае вы не указали _rec_ name, ваше 
отображаемое имя будет представлять собой комбинацию имени модели и идентификатора 
записи, например: (library.book, 1).

Поскольку мы добавили в модель новое поле short_name, Odoo ORM добавит новый столбец 
в таблицу базы данных, но не будет отображать это поле в представлении. Для этого 
необходимо добавить это поле в представление формы. На шаге 4 мы добавили поле 
short_name в представление формы.

Есть больше...

Представление записи доступно в вычисляемом поле magic display_name и было 
автоматически добавлено во все модели, начиная с версии 8.0. Его значения 
генерируются с использованием метода модели name_get(), который уже существовал 
в предыдущих версиях Odoo.

Реализация по умолчанию name_get() использует атрибут _rec_name, чтобы найти, 
какое поле содержит данные, которые используются для генерации отображаемого имени. 
Если вам нужна собственная реализация отображаемого имени, вы можете переопределить 
логику name_get(), чтобы сгенерировать настраиваемое отображаемое имя. Метод должен 
возвращать список кортежей с двумя элементами: идентификатором записи и строковым 
представлением записи в Юникоде.

Например, чтобы иметь название и дату его выпуска в представлении, например 
Моби Дик (1851-10-18), мы можем определить следующее:

Взгляните на следующий пример. Это добавит дату выпуска в название записи:

def name_get(self):
    result = []
    for record in self:
        rec_name = "%s (%s)" % (record.name, record.date_release)
        result.append((record.id, rec_name))
    return result

После добавления предыдущего кода ваша запись display_name будет обновлена. 
Предположим, у вас есть запись с именем Odoo Cookbook и датой выпуска 19-04-2019, 
тогда предыдущий метод name_get() сгенерирует имя, такое как Odoo Cookbook (19-04-2019).

Добавление полей данных в модель

Модели предназначены для хранения данных, и эти данные структурированы по полям. 
Здесь вы узнаете о нескольких типах данных, которые могут храниться в полях, и о том, 
как добавить их в модель.

Готовиться

Этот рецепт предполагает, что у вас есть готовый экземпляр с доступным дополнительным 
модулем my_library, как описано в главе 3, Создание дополнительных модулей Odoo.

Как это сделать...

В дополнительном модуле my_library уже должен быть файл models/library_book.py, 
определяющий базовую модель. Мы отредактируем его, чтобы добавить новые поля:

1. Используйте минимальный синтаксис для добавления полей в модель библиотечных книг:

from odoo import models, fields
class LibraryBook(models.Model):
    # ...
    short_name = fields.Char('Short Title')
    notes = fields.Text('Internal Notes')
    state = fields.Selection(
        [('draft', 'Not Available'),
        ('available', 'Available'),
        ('lost', 'Lost')],
        'State')
    description = fields.Html('Description')
    cover = fields.Binary('Book Cover')
    out_of_print = fields.Boolean('Out of Print?')
    date_release = fields.Date('Release Date')
    date_updated = fields.Datetime('Last Updated')
    pages = fields.Integer('Number of Pages')
    reader_rating = fields.Float(
        'Reader Average Rating',
        digits=(14, 4), # Optional precision decimals,
    )

2. Мы добавили в модель новые поля. Нам все еще нужно добавить эти поля в представление 
формы, чтобы отразить эти изменения в пользовательском интерфейсе. Обратитесь к следующему 
коду, чтобы добавить поля в представление формы:

<form>
    <group>
        <group>
            <field name="name"/>
            <field name="author_ids" widget="many2many_tags"/>
            <field name="state"/>
            <field name="pages"/>
            <field name="notes"/>
        </group>
        <group>
            <field name="short_name"/>
            <field name="date_release"/>
            <field name="date_updated"/>
            <field name="cover" widget="image" class="oe_avatar"/>
            <field name="reader_rating"/>
        </group>
    </group>
    <group>
        <field name="description"/>
    </group>
</form>

Обновление модуля сделает эти изменения эффективными в модели Odoo.

Взгляните на следующие образцы различных полей. Здесь мы использовали разные 
атрибуты для разных типов полей. Это даст вам лучшее представление об объявлении поля:

short_name = fields.Char('Short Title',translate=True, index=True)
state = fields.Selection(
    [('draft', 'Not Available'),
        ('available', 'Available'),
        ('lost', 'Lost')],
    'State', default="draft")
description = fields.Html('Description', sanitize=True, strip_style=False)
pages = fields.Integer('Number of Pages',
    groups='base.group_user',
    states={'lost': [('readonly', True)]},
    help='Total book page count', company_dependent=False)

Как это работает...

Поля добавляются к моделям путем определения атрибута в их классах Python. Доступны 
следующие нереляционные типы полей:

• Char используется для строковых значений.

• Текст используется для многострочных строковых значений.

• Выбор используется для списков выбора. Это список значений и пар описания.
Выбранное значение сохраняется в базе данных и может быть строкой или целым числом. 
Описание переводится автоматически.

Важная заметка

В полях типа Selection вы можете использовать целочисленные ключи, но вы должны знать, 
что Odoo интерпретирует 0 как не установленный внутри, и не будет отображать описание, 
если сохраненное значение равно нулю. Это может случиться, поэтому вам нужно будет это учитывать.

• Html похож на текстовое поле, но предполагается, что он будет хранить богатый текст в формате HTML.

• Двоичные поля хранят двоичные файлы, такие как изображения или документы.

• Boolean хранит значения True / False.

• Дата хранит значения даты. Они хранятся в базе данных как даты. ORM обрабатывает их в виде 
объектов даты Python. Вы можете использовать fields.Date.today (), чтобы установить текущую 
дату как значение по умолчанию в поле даты.

• Datetime используется для значений datetime. Они хранятся в базе данных в наивном 
datetime по времени UTC. ORM обрабатывает их в виде объектов даты и времени Python. 
Вы можете использовать fields.Date.now (), чтобы установить текущее время в качестве 
значения по умолчанию в поле datetime.

• Целочисленные поля не нуждаются в дополнительных пояснениях.

• Поля с плавающей запятой хранят числовые значения. Их точность при желании может 
быть определена с помощью общего количества цифр и пар десятичных цифр.

• В денежном выражении может храниться сумма в определенной валюте. Это также будет 
объяснено в разделе «Добавление денежного поля» в этой главе.

Первый шаг этого рецепта показывает минимальный синтаксис, который нужно добавить 
к каждому типу поля. Определения полей можно расширить, добавив другие необязательные 
атрибуты, как показано на шаге 2.

Вот объяснение использованных атрибутов поля:

• строка - заголовок поля и используется в метках представления пользовательского интерфейса. 
Это необязательно. Если не установлен, метка будет производиться от имени поля путем добавления 
регистра заголовка и замены подчеркивания пробелами.

• translate, если установлено значение True, делает поле переводимым. Он может иметь 
различное значение в зависимости от языка пользовательского интерфейса.

• default - значение по умолчанию. Это также может быть функция, которая используется 
для вычисления значения по умолчанию; например, default = _compute_default, где _compute_default - 
это метод, который был определен в модели до определения поля.

• help - это текст объяснения, который отображается во всплывающих подсказках пользовательского 
интерфейса.

• groups делает поле доступным только для некоторых групп безопасности. Это строка, 
содержащая разделенный запятыми список идентификаторов XML для групп безопасности. 
Более подробно это рассматривается в главе 10 «Безопасный доступ».

• States позволяет пользовательскому интерфейсу динамически устанавливать значения 
атрибутов readonly, required и invisible в зависимости от значения поля состояния.
Следовательно, для этого требуется, чтобы поле состояния существовало и использовалось 
в представлении формы (даже если оно невидимо). Имя атрибута состояния жестко запрограммировано 
в Odoo и не может быть изменено.

• copy указывает, копируется ли значение поля при дублировании записи. По умолчанию это 
True для нереляционных полей и полей Many2one и False для One2many и вычисляемых полей.

• index, если установлено значение True, создает индекс базы данных для поля, что иногда 
позволяет ускорить поиск. Он заменяет устаревший атрибут select = 1.

• Флаг readonly делает поле доступным только для чтения по умолчанию в пользовательском интерфейсе.

• Наличие флага required делает поле обязательным по умолчанию в пользовательском интерфейсе.
Упомянутые здесь различные белые списки определены в odoo/tools/mail.py.

• Флаг company_dependent заставляет поле хранить разные значения для каждой компании. Он 
заменяет устаревший тип поля Property.

• group_operator - агрегатная функция, используемая для отображения результатов в 
режиме группировки. Возможные значения для этого атрибута включают count, count_distinct, 
array_agg, bool_and, bool_or, max, min, avg и sum. Типы полей Integer, Float и Monetary 
имеют для этого атрибута значение по умолчанию sum.

• Флаг очистки используется полями HTML и удаляет его содержимое из потенциально 
небезопасных тегов. При этом выполняется глобальная очистка ввода.

Если вам нужен более точный контроль при очистке HTML, вы можете использовать еще 
несколько атрибутов, которые работают, только если включена очистка:

• sanitize_tags = True, чтобы удалить теги, не входящие в белый список (это значение по умолчанию)

• sanitize_attributes = True, чтобы удалить атрибуты тегов, которые не являются частью белого списка.

• sanitize_style = True, чтобы удалить свойства стиля, не входящие в белый список.

• strip_style = True, чтобы удалить все элементы стиля

• strip_class = True, чтобы удалить атрибуты класса

Наконец, мы обновили вид формы в соответствии с недавно добавленными полями в модели. 
Мы разместили здесь теги <field> произвольным образом, но вы можете разместить их где угодно. 
Представления форм более подробно описаны в главе 9, Представления серверной части.

Есть больше...

Поле Selection также принимает ссылку на функцию в качестве атрибута выбора вместо списка. 
Это позволяет динамически генерировать списки опций. Вы можете найти пример, относящийся 
к этому, в рецепте Добавление динамических отношений с использованием ссылочных полей в 
этой главе, где также используется атрибут выбора.

Объекты полей Date и Datetime предоставляют несколько удобных служебных методов.

Для Date у нас есть следующее:

• fields.Date.to_date (string_value) преобразует строку в объект даты.

• fields.Date.to_string (date_value) преобразует объект Date Python в строку.

• fields.Date.today () возвращает текущий день в строковом формате. Это подходит для 
значений по умолчанию.

• fields.Date.context_today (record, timestamp) возвращает день метки времени 
(или текущий день, если метка времени не указана) в строковом формате в соответствии 
с часовым поясом контекста записи (или набора записей).

Для Datetime у нас есть следующее:

• fields.Datetime.to_datetime (string_value) преобразует строку в объект datetime.

• fields.Datetime.to_string (datetime_value) преобразует объект datetime в строку.

• fields.Datetime.now () возвращает текущий день и время в строковом формате.
Это подходит для значений по умолчанию.

• fields.Datetime.context_timestamp (record, timestamp) преобразует объект datetime с 
меткой времени в объект datetime с учетом часового пояса, используя часовой пояс в 
контексте записи. Это не подходит для значений по умолчанию, но может использоваться в 
случаях, когда вы отправляете данные во внешнюю систему.

Помимо основных полей, у нас также есть реляционные поля: Many2one, One2many и Many2many. 
Они объясняются в разделе «Добавление реляционных полей в рецепт модели» в этой главе.

Также возможно иметь поля с автоматически вычисляемыми значениями, определяя 
функцию вычисления с атрибутом вычисляемого поля. Это объясняется в разделе 
«Добавление вычисленных полей в рецепт модели».

Некоторые поля добавляются по умолчанию в моделях Odoo, поэтому мы не должны использовать 
эти имена для наших полей. Это поле id для автоматически сгенерированного идентификатора 
записи и несколько полей журнала аудита, а именно:

• create_date - отметка времени создания записи.

• create_uid - пользователь, создавший запись.

• write_date - это последнее записанное изменение метки времени.

• write_uid - это пользователь, который последним редактировал запись.

Автоматическое создание этих полей журнала можно отключить, установив атрибут модели _log_access = False.

Еще один специальный столбец, который можно добавить в модель, активен. Это должно быть 
логическое поле, позволяющее пользователям отмечать записи как неактивные. Он используется 
для включения функции архивирования / разархивирования записей. Его определение таково:

active = fields.Boolean('Active', default=True)

По умолчанию видны только записи с активным значением True. Чтобы получить их, нам нужно 
использовать фильтр домена с [('active', '=', False)]. В качестве альтернативы, если 
значение active_test: False добавлено в контекст среды, ORM не будет отфильтровывать неактивные записи.

В некоторых случаях вы не сможете изменить контекст, чтобы получить как активные, 
так и неактивные записи. В этом случае вы можете использовать домен 
['|', ('active', = ', True), (' active ',' = ', False)].

Осторожность

[('active', 'in' (True, False))] работает не так, как вы могли ожидать. 
Odoo явно ищет предложение ('active', '=', False) в домене. По умолчанию поиск 
будет ограничен только активными записями.

Использование поля с плавающей запятой с настраиваемой точностью

При использовании полей с плавающей запятой мы можем позволить конечному пользователю 
настроить десятичную точность, которая будет использоваться. В этом рецепте мы добавим 
поле «Стоимость» в модель «Библиотечные книги» с настраиваемой пользователем точностью 
до десятичной дроби.

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Выполните следующие шаги, чтобы применить динамическую десятичную точность к полю cost_price модели:

1. Активируйте режим разработчика по ссылке в меню «Настройки» (см. Рецепт 
«Активация инструментов разработчика Odoo» в главе 1, «Установка среды разработки Odoo»). 
Это активирует Настройки | Техническое меню.

2. Доступ к конфигурациям десятичной точности. Для этого откройте верхнее меню «Настройки» 
и выберите «Технические | Структура базы данных | Десятичная точность. Мы должны увидеть 
список текущих настроек.

3. Добавьте новую конфигурацию, установив для использования значение «Книжная цена» и 
выбрав точность в цифрах:

Figure 4.2 – Creating new decimal precision

4. Чтобы добавить поле модели с использованием этого параметра точности десятичной дроби, 
отредактируйте файл models/library_book.py, добавив следующий код:

class LibraryBook(models.Model):
    cost_price = fields.Float(
                            'Book Cost', digits='Book Price')

Кончик

Каждый раз, когда вы добавляете новые поля в модели, вам нужно будет добавить их в представления, 
чтобы получить к ним доступ из пользовательского интерфейса. В предыдущем примере мы добавили 
поле cost_price. Чтобы увидеть это в представлении формы, вам нужно добавить его с помощью 
<field name="cost_price"/>.

Как это работает...

Когда вы добавляете строковое значение к атрибуту digits поля, Odoo ищет эту строку в поле 
Usage модели десятичной точности и возвращает кортеж с точностью до 16 цифр и количеством 
десятичных знаков, которые были определены в конфигурации. Использование определения поля 
вместо его жесткого программирования позволяет конечному пользователю настроить его в 
соответствии со своими потребностями.

Кончик

Если вы используете версию старше v13, вам потребуется дополнительная работа, чтобы 
использовать атрибут digits в полях с плавающей запятой. В более старых версиях десятичная 
точность была доступна в отдельном модуле decimal_precision. Чтобы включить настраиваемую 
десятичную точность в вашем поле, вы должны использовать метод get_precision() модуля 
decimal_precision, например: cost_price = fields.Float ('Book Cost', 
digits = dp.get_precision ('Book Price')).

Добавление денежного поля в модель

Odoo имеет специальную поддержку денежных значений, связанных с валютой. Давайте посмотрим, 
как мы можем использовать это в модели.

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Денежное поле нуждается в дополнительном поле валюты для хранения валюты сумм.

В my_library уже есть models / library_book.py, которые определяют базовую модель.
Мы отредактируем это, чтобы добавить обязательные поля:

1. Добавьте поле для хранения валюты, которая будет использоваться:

class LibraryBook(models.Model):
    # ...
    currency_id = fields.Many2one(
                                'res.currency', string='Currency')

2. Добавьте денежное поле для хранения суммы:

class LibraryBook(models.Model):
    # ...
    retail_price = fields.Monetary(
        'Retail Price',
        # optional: currency_field='currency_id',
        )

Теперь обновите дополнительный модуль, и в модели должны появиться новые поля.
Они не будут видны в представлениях, пока не будут добавлены к ним, но мы можем подтвердить 
их добавление, проверив поля модели в 
Настройках | Технические | Структура базы данных | Модели в режиме разработчика.

После добавления их в представление формы оно будет выглядеть следующим образом:

Figure 4.3 – Currency symbol in the monetary field

Как это работает...

Денежные поля похожи на поля с плавающей запятой, но Odoo может правильно представлять их 
в пользовательском интерфейсе, поскольку он знает, какая у них валюта, через второе поле.
Ожидается, что это поле валюты будет называться currency_id, но мы можем использовать любое 
имя поля, которое нам нравится, если оно указано с помощью необязательного параметра currency_field.

Кончик

Вы можете опустить атрибут currency_field в денежном поле, если вы храните информацию о 
валюте в поле с именем currency_id.

Это очень полезно, когда вам нужно вести суммы в разных валютах в одной записи. Например, 
если мы хотим включить валюту заказа на продажу и валюту компании, вы можете настроить два 
поля как поля. Много2one (res.currency) и использовать первое для первой суммы, а другое - 
для второй суммы.

Возможно, вы захотите узнать, что десятичная точность для суммы взята из определения 
валюты (поле десятичной точности модели red.currency).

Добавление реляционных полей в модель

Отношения между моделями Odoo представлены реляционными полями. Есть три разных типа отношений:

• многие к одному, обычно сокращенно m2o

• «один ко многим», обычно сокращенно o2m

• многие ко многим, обычно сокращенно m2m

Глядя на пример библиотечных книг, мы видим, что у каждой книги может быть только один издатель, 
поэтому между книгами и издателями может быть связь «многие к одному».

Однако у каждого издателя может быть много книг. Итак, предыдущее отношение «многие к одному» 
подразумевает обратное отношение «один ко многим».

Наконец, есть случаи, когда мы можем иметь отношение «многие ко многим». В нашем примере у 
каждой книги может быть несколько (много) авторов. И наоборот, каждый автор мог написать 
много книг. Если посмотреть на это с любой стороны, это отношение «многие ко многим».

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Odoo использует партнерскую модель res.partner для представления людей, организаций и 
адресов. Мы должны использовать его для авторов и издателей. Мы отредактируем файл 
models/library_book.py, чтобы добавить эти поля:

1. Добавьте поле "многие к одному" для издателя книги в Библиотечные книги:

class LibraryBook(models.Model):
    # ...
    publisher_id = fields.Many2one(
        'res.partner', string='Publisher',
        # optional:
        ondelete='set null',
        context={},
        domain=[],
        )

2. Чтобы добавить поле «один ко многим» для книг издателя, нам необходимо расширить 
партнерскую модель. Для простоты мы добавим это в тот же файл Python:

class ResPartner(models.Model):
    _inherit = 'res.partner'
    published_book_ids = fields.One2many(
                                    'library.book', 'publisher_id',
                                    string='Published Books')

Атрибут _inherit, который мы здесь используем, предназначен для наследования 
существующей модели. Это будет объяснено в разделе «Добавление элементов в модель 
с использованием рецепта наследования» далее в этой главе.

3. Мы уже создали отношение «многие ко многим» между книгами и авторами, 
но давайте вернемся к нему:

class LibraryBook(models.Model):
    # ...
    author_ids = fields.Many2many(
                    'res.partner', string='Authors')


4. То же отношение, но от авторов к книгам, следует добавить к партнерской модели:

class ResPartner(models.Model):
    # ...
    authored_book_ids = fields.Many2many(
        'library.book',
        string='Authored Books',
        # relation='library_book_res_partner_rel' #optional
        )

Теперь обновите дополнительный модуль, и в модели должны появиться новые поля.
Они не будут видны в представлениях, пока не будут добавлены к ним, но мы можем подтвердить 
их добавление, проверив поля модели в 
Настройках | Технические | Структура базы данных | Модели в режиме разработчика.

Как это работает...

Поля «многие к одному» добавляют столбец в таблицу базы данных модели, в которой хранится 
идентификатор базы данных связанной записи. На уровне базы данных также будет создано 
ограничение внешнего ключа, гарантирующее, что сохраненные идентификаторы являются 
действительной ссылкой на запись в связанной таблице.
Для этих полей отношения не создается индекс базы данных, но это можно сделать, 
добавив атрибут index = True.

Мы видим, что есть еще четыре атрибута, которые мы можем использовать для полей типа 
"многие к одному". Атрибут ondelete определяет, что происходит при удалении связанной 
записи. Например, что происходит с книгами, когда их запись об издателе удаляется? По 
умолчанию установлено значение «set null», при котором в поле устанавливается пустое 
значение. Это также может быть «ограничить», что препятствует удалению связанной записи, 
или «каскад», при котором связанная запись также удаляется.

Последние два (контекст и домен) также действительны для других реляционных полей. 
Они в основном значимы на стороне клиента, а на уровне модели действуют как значения 
по умолчанию, которые будут использоваться в представлениях на стороне клиента:

• context добавляет переменные в контекст клиента при щелчке по полю в представлении 
связанной записи. Мы можем, например, использовать его для установки значений по умолчанию 
для новых записей, которые создаются с помощью этого представления.

• домен - это фильтр поиска, который используется для ограничения списка доступных 
связанных записей.

И контекст, и домен более подробно описаны в главе 9, Backend Views.

Поля «один ко многим» являются противоположностью отношений «многие к одному», 
и хотя они добавляются в модели так же, как и другие поля, они не имеют реального 
представления в базе данных. Вместо этого они представляют собой программные ярлыки, 
и они позволяют представлениям представлять эти списки связанных записей. Это означает, 
что для полей типа «один ко многим» требуется поле «многие к одному» в эталонной модели. 
В нашем примере мы добавили поле «один ко многим», унаследовав партнерскую модель. Мы 
подробно рассмотрим наследование модели в разделе «Добавление функций в модель с использованием 
рецепта наследования» в этой главе. В нашем примере поле «один-ко-многим» published_book_ids 
имеет ссылку на поле publisher_id модели library.book.

Отношения «многие ко многим» также не добавляют столбцы в таблицы для моделей. Этот 
тип отношения представлен в базе данных с помощью промежуточной таблицы отношений 
с двумя столбцами для хранения двух связанных идентификаторов. Добавление нового 
отношения между книгой и автором создает новую запись в таблице отношений с идентификатором 
книги и идентификатором автора.

Odoo автоматически обрабатывает создание этой таблицы отношений. Имя таблицы отношений 
по умолчанию строится с использованием имен двух связанных моделей, отсортированных по 
алфавиту, а также суффикса _rel. Однако мы можем переопределить это, используя атрибут отношения.

Следует иметь в виду, что имена двух таблиц достаточно велики, чтобы автоматически 
сгенерированные идентификаторы базы данных превышали лимит PostgreSQL в 63 символа. 
Как правило, если имена двух связанных таблиц превышают 23 символа, вы должны использовать 
атрибут отношения, чтобы установить более короткое имя. В следующем разделе мы более подробно 
остановимся на этом.

Есть больше...

Поля Many2one поддерживают дополнительный атрибут auto_join. Это флаг, который позволяет 
ORM использовать SQL-соединения в этом поле. Благодаря этому он обходит обычный контроль ORM, 
такой как контроль доступа пользователей и правила доступа к записям. В определенных случаях 
он может решить проблемы с производительностью, но рекомендуется избегать его использования.

Мы рассмотрели кратчайший способ определения реляционных полей. Давайте посмотрим 
на атрибуты, характерные для этого типа поля.

Атрибуты поля One2many следующие:

• comodel_name: это идентификатор целевой модели, обязательный для всех реляционных 
полей, но его можно определять позиционно без ключевого слова.

• inverse_name: это применимо только к One2many и является именем поля в целевой модели 
для обратного отношения Many2one.

• limit: это относится к One2many и Many2many и устанавливает необязательный предел количества 
записей для чтения, которые используются на уровне пользовательского интерфейса.

Атрибуты поля Many2many следующие:

• comodel_name: то же самое, что и для поля One2many.

• отношение: это имя, которое следует использовать для таблицы, поддерживающей отношение, заменяя 
автоматически определенное имя.

• column1: это имя поля Many2one в реляционной таблице, связанной с этой моделью.

• column2: это имя поля Many2one в реляционной таблице, связанной с comodel.

Для отношений Many2many в большинстве случаев ORM позаботится о значениях по умолчанию 
для этих атрибутов. Он даже способен обнаруживать обратные отношения Many2many, обнаруживать 
уже существующую таблицу отношений и соответствующим образом инвертировать значения column1 и column2.

Однако есть два случая, когда нам нужно вмешаться и предоставить собственные значения для этих атрибутов:

• Один из них - это случай, когда нам нужно более одного отношения Many2many между одними и теми же 
двумя моделями. Чтобы это было возможно, мы должны предоставить себе имя таблицы отношений для 
второго отношения, которое должно отличаться от первого отношения.

• Другой случай - это когда имена базы данных связанных таблиц достаточно длинные, чтобы 
автоматически созданное имя отношения превышало лимит PostgreSQL в 63 символа для имен 
объектов базы данных.

Автоматическое имя таблицы отношений - <model1> _ <model2> _rel. Однако эта таблица отношений 
также создает индекс для своего первичного ключа со следующим идентификатором:

<model1>_<model2>_rel_<model1>_id_<model2>_id_key

Этот первичный ключ также должен соответствовать ограничению в 63 символа. Таким образом, 
если объединенные имена двух таблиц превышают в общей сложности 63 символа, у вас, вероятно, 
возникнут проблемы с соблюдением ограничений, и вам нужно будет вручную установить атрибут отношения.

Добавление иерархии в модель

Иерархии представлены как модель, имеющая отношения с одной и той же моделью. Каждая запись 
имеет родительскую запись в той же модели и множество дочерних записей. Этого можно достичь, 
просто используя отношения «многие к одному» между моделью и самой собой.

Однако Odoo также обеспечивает улучшенную поддержку этого типа поля за счет использования модели 
вложенного набора (https://en.wikipedia.org/wiki/Nested_set_model).
При активации запросы, использующие оператор child_of в своих фильтрах домена, 
будут выполняться значительно быстрее.

Оставаясь с примером библиотечных книг, мы построим иерархическое дерево категорий, 
которое можно использовать для категоризации книг.

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Мы добавим новый файл Python, models / library_book_categ.py, для дерева категорий, как показано ниже:

1. Чтобы загрузить новый файл кода Python, добавьте следующую строку в models / __ init__.py:

from . import library_book_categ

2. Чтобы создать модель категории книги с родительскими и дочерними отношениями, создайте 
файл models/library_book_categ.py со следующим кодом:

from odoo import models, fields, api
class BookCategory(models.Model):
    _name = 'library.book.category'
    name = fields.Char('Category')
    parent_id = fields.Many2one(
                            'library.book.category',
                            string='Parent Category',
                            ondelete='restrict',
                            index=True)
    child_ids = fields.One2many(
                            'library.book.category', 'parent_id',
                            string='Child Categories')

3. Чтобы включить поддержку специальной иерархии, добавьте также следующий код:

_parent_store = True
_parent_name = "parent_id" # optional if field is 'parent_id'
parent_path = fields.Char(index=True)

4. Чтобы добавить проверку, предотвращающую зацикливание отношений, добавьте в модель следующую строку:

from odoo.exceptions import ValidationError
...
@api.constraints('parent_id')
def _check_hierarchy(self):
    if not self._check_recursion():
        raise models.ValidationError(
            'Error! You cannot create recursive categories.')

5. Теперь нам нужно присвоить книге категорию. Для этого добавим в модель library.book новое поле many2one:

category_id = fields.Many2one('library.book.category')

Наконец, обновление модуля сделает эти изменения эффективными.

Чтобы отобразить модель librart.book.category в пользовательском интерфейсе, вам нужно будет 
добавить меню, представления и правила безопасности. Дополнительные сведения см. В главе 3 
«Создание дополнительных модулей Odoo». Кроме того, вы можете получить доступ ко всему коду 
на https://github.com/PacktPublishing/Odoo-13-Development-Cookbook-Fourth-Edition.

Как это работает...

Шаги 1 и 2 создают новую модель с иерархическими отношениями. Отношение Many2one добавляет 
поле для ссылки на родительскую запись. Для более быстрого обнаружения дочерних записей это 
поле индексируется в базе данных с помощью параметра index = True. В поле parent_id должно 
быть установлено значение ondelete либо «cascade», либо «restrict». На данный момент у нас есть 
все, что требуется для создания иерархической структуры, но есть еще несколько дополнений, 
которые мы можем сделать для ее улучшения. Отношение One2many не добавляет никаких дополнительных 
полей в базу данных, но предоставляет ярлык для доступа ко всем записям с этой записью в качестве 
их родительской.

На шаге 3 мы активируем специальную поддержку иерархий. Это полезно для инструкций с высокой 
скоростью чтения, но с низким уровнем записи, поскольку обеспечивает более быстрый просмотр данных 
за счет более дорогостоящих операций записи. Это делается путем добавления одного вспомогательного 
поля, parent_path, и установки для атрибута модели значения _parent_store = True. Когда этот атрибут 
включен, вспомогательное поле будет использоваться для хранения данных при поиске в иерархическом 
дереве. По умолчанию предполагается, что поле для родительской записи называется parent_id, но 
также можно использовать другое имя. В этом случае правильное имя поля должно быть указано с 
помощью дополнительного атрибута модели _parent_name. По умолчанию это выглядит следующим образом:

_parent_name = 'parent_id'

Шаг 4 рекомендуется для предотвращения циклических зависимостей в иерархии, что означает наличие 
записи как в восходящем, так и в нисходящем деревьях. Это опасно для программ, которые перемещаются 
по дереву, так как они могут попасть в бесконечный цикл. models.Model предоставляет для этого 
служебный метод (_check_recursion), который мы здесь повторно использовали.

Шаг 5 - добавить в библиотеку поле идентификатора категории с типом many2one.
Книжная книга, чтобы мы могли установить категорию для книжных записей. Это 
просто для завершения нашего примера.

Есть больше...

Показанный здесь метод следует использовать для статических иерархий, которые часто читаются 
и запрашиваются, но обновляются реже. Категории книг являются хорошим примером, поскольку 
библиотека не будет постоянно создавать новые категории; однако читатели часто ограничивают 
свой поиск категорией и ее дочерними категориями. Причина этого заключается в реализации модели 
вложенных множеств в базе данных, которая требует обновления столбца parent_path (и связанных 
индексов базы данных) для всех записей всякий раз, когда категория вставляется, удаляется или 
перемещается. Это может быть очень дорогостоящей операцией, особенно когда несколько выпусков 
выполняются в параллельных транзакциях.

Если вы имеете дело с очень динамической иерархической структурой, стандартные отношения 
parent_id и child_ids часто приводят к лучшей производительности, избегая блокировок на 
уровне таблицы.

Добавление проверок ограничений в модель

Модели могут иметь проверки, предотвращающие их попадание в нежелательные условия.

Odoo поддерживает два разных типа ограничений:

• Проверенные на уровне базы данных

• Проверенные на уровне сервера

Ограничения уровня базы данных ограничиваются ограничениями, поддерживаемыми PostgreSQL. 
Чаще всего используются ограничения UNIQUE, но также можно использовать ограничения CHECK и 
EXCLUDE. Если этого недостаточно для наших нужд, мы можем использовать ограничения уровня 
сервера Odoo, написанные в коде Python.

Мы будем использовать модель «Библиотечные книги», которую мы создали в главе 3 
«Создание дополнительных модулей Odoo», и добавим к ней несколько ограничений. Мы добавим 
ограничение базы данных, которое предотвращает дублирование названий книг, и ограничение 
модели Python, которое предотвращает даты выпуска в будущем.

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта. 
Мы ожидаем, что он будет содержать как минимум следующее:

from odoo import models, fields
class LibraryBook(models.Model):
    _name = 'library.book'
    name = fields.Char('Title', required=True)
    date_release = fields.Date('Release Date')

Как это сделать...

Мы отредактируем класс LibraryBook в файле Python models / library_book.py:

1. Чтобы создать ограничение базы данных, добавьте атрибут модели:

class LibraryBook(models.Model):
    # ...
    _sql_constraints = [
        ('name_uniq', 'UNIQUE (name)',
            'Book title must be unique.'),
        ('positive_page', 'CHECK(pages>0)',
            'No of pages must be positive')
        ]

2. To create the Python code constraint, add a model method:

from odoo import api, models, fields
from odoo.exceptions import ValidationError
class LibraryBook(models.Model):
    # ...
    @api.constrains('date_release')
    def _check_release_date(self):
    for record in self:
        if record.date_release and
                record.date_release > fields.Date.today():
            raise models.ValidationError(
                'Release date must be in the past')

После внесения этих изменений в файл кода необходимо обновить дополнительный модуль и перезапустить сервер.

Как это работает...

Первый шаг создает ограничение базы данных для таблицы модели. Это применяется на уровне базы данных. 
Атрибут модели _sql_constraints принимает список создаваемых ограничений. Каждое ограничение определяется 
трехэлементным кортежем. Они перечислены ниже:

• Суффикс для идентификатора ограничения. В нашем примере мы использовали name_uniq, и получившееся 
имя ограничения - library_book_name_uniq.

• SQL для использования в инструкции PostgreSQL для изменения или создания таблицы базы данных.

• Сообщение, чтобы сообщить пользователю, когда ограничение нарушено.

Предупреждение

Если вы добавляете ограничения SQL к существующей модели посредством наследования модели, 
убедитесь, что у вас нет строк, нарушающих ограничения. Если у вас есть такие строки, то 
ограничения SQL не будут добавлены, и в журнале будет сгенерирована ошибка.

Как мы упоминали ранее, также могут использоваться другие ограничения таблицы базы данных. 
Обратите внимание, что таким образом нельзя добавить ограничения столбца, такие как NOT NULL. 
Для получения дополнительной информации об ограничениях PostgreSQL в целом и ограничениях таблиц 
в частности, посетите http://www.postgresql.org/docs/current/static/ddl-constraints.html.

На втором этапе мы добавили метод проверки кода Python. Он украшен @api.constrains, 
что означает, что он должен выполняться для запуска проверок при изменении одного из полей в 
списке аргументов. Если проверка завершится неудачно, возникнет исключение ValidationError.

Есть больше...

Обычно, если вам нужна сложная проверка, вы можете использовать @ api.constrains, но для 
некоторых простых случаев вы можете использовать _sql_constraints с опцией CHECK. Взгляните 
на следующий пример:

_sql_constraints = [
    ( 'check_credit_debit',
    'CHECK(credit + debit>=0 AND credit * debit=0)',
    'Wrong credit or debit value in accounting entry!'
    )
]

В предыдущем примере мы использовали опцию CHECK и проверяем несколько условий в одних и тех 
же ограничениях с помощью оператора AND.

Добавление вычисляемых полей в модель

Иногда нам нужно иметь поле, значение которого вычислено или получено из других полей в той 
же записи или в связанных записях. Типичным примером является общая сумма, которая рассчитывается 
путем умножения цены за единицу на количество. В моделях Odoo этого можно достичь с помощью 
вычисляемых полей.

Чтобы показать вам, как работают вычисляемые поля, мы добавим одно в модель «Библиотечные книги» 
для расчета дней с даты выпуска книги.

Чтобы показать вам, как работают вычисляемые поля, мы добавим одно в модель «Библиотечные книги» 
для расчета дней с даты выпуска книги.

Также можно сделать вычисляемые поля доступными для редактирования и поиска. Мы также 
реализуем это на нашем примере.

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Мы отредактируем файл кода models / library_book.py, чтобы добавить новое поле и методы, 
поддерживающие его логику:

1. Начните с добавления нового поля в модель Библиотечные книги:

class LibraryBook(models.Model):
    # ...
    age_days = fields.Float(
        string='Days Since Release',
        compute='_compute_age',
        inverse='_inverse_age',
        search='_search_age',
        store=False, # optional
        compute_sudo=True # optional
    )

2. Затем добавьте метод с логикой вычисления значения:

# ...
from odoo import api # if not already imported
# ...
class LibraryBook(models.Model):
    # ...
    @api.depends('date_release')
    def _compute_age(self):
        today = fields.Date.today()
        for book in self:
            if book.date_release:
                delta = today - book.date_release
                book.age_days = delta.days
            else:
                book.age_days = 0

3. Чтобы добавить метод и реализовать логику записи в вычисляемом поле, используйте следующий код:

from datetime import timedelta
# ...
class LibraryBook(models.Model):
    # ...
    def _inverse_age(self):
        today = fields.Date.today()
        for book in self.filtered('date_release'):
            d = today - timedelta(days=book.age_days)
            book.date_release = d

4. Чтобы реализовать логику, которая позволит вам искать в вычисляемом поле, используйте следующий код:

from datetime import timedelta
class LibraryBook(models.Model):
    # ...
    def _search_age(self, operator, value):
        today = fields.Date.today()
        value_days = timedelta(days=value)
        value_date = today - value_days
        # convert the operator:
        # book with age > value have a date < value_date
        operator_map = {
            '>': '<', '>=': '<=',
            '<': '>', '<=': '>=',
        }
        new_op = operator_map.get(operator, operator)
        return [('date_release', new_op, value_date)]

Для правильной активации этих новых дополнений требуется перезапуск Odoo с последующим обновлением модуля.

Как это работает ... 

Определение вычисляемого поля такое же, как определение обычного поля, за исключением того, что 
добавляется атрибут вычисления, чтобы указать имя метода, используемого для его вычисления. 

Их сходство может быть обманчивым, поскольку вычисляемые поля внутренне сильно отличаются от обычных полей. 
Вычисляемые поля динамически вычисляются во время выполнения, и по этой причине они не хранятся в базе 
данных, поэтому вы не можете выполнять поиск или запись в вычисляемых полях по умолчанию. 
Вам нужно проделать некоторую дополнительную работу, чтобы включить поддержку записи и поиска для 
полей вычислений. Посмотрим, как это сделать. 

Вычислительная функция динамически вычисляется во время выполнения, но ORM использует 
кеширование, чтобы избежать неэффективного пересчета ее каждый раз при обращении к ее значению. 
Итак, ему нужно знать, от каких еще полей он зависит. Он использует декоратор @depends, чтобы определить, 
когда его кешированные значения должны быть признаны недействительными и пересчитаны. 

Убедитесь, что функция вычисления всегда устанавливает значение в вычисляемом поле. 
В противном случае возникнет ошибка. Это может произойти, если в вашем коде есть условия 
if, которые иногда не могут установить значение в вычисляемом поле. Это может быть сложно отладить.

Поддержка записи может быть добавлена путем реализации обратной функции. Это использует значение, 
присвоенное вычисляемому полю, для обновления полей происхождения. Конечно, это имеет смысл только для 
простых вычислений. Тем не менее, есть случаи, когда это может быть полезно. В нашем примере мы позволяем 
установить дату выпуска книги, отредактировав вычисляемое поле «Дни с момента выпуска». Обратный атрибут 
не является обязательным; если вы не хотите делать поле вычислений доступным для редактирования, 
вы можете пропустить его.

Также возможно сделать несохраненное вычисляемое поле доступным для поиска, установив для атрибута 
поиска имя метода (аналогично вычислению и инверсии). Как и в обратном порядке, поиск также 
необязателен; если вы не хотите, чтобы поле вычислений было доступным для поиска, вы можете пропустить его.

Однако не ожидается, что этот метод будет реализовывать фактический поиск. Вместо этого он получает 
в качестве параметров оператор и значение, используемые для поиска в поле, и, как ожидается, вернет 
домен с используемыми условиями поиска замены. В нашем примере мы переводим поиск в поле 
«Дни с момента выпуска» в эквивалентное условие поиска в поле «Дата выпуска».

Необязательный флаг store = True сохраняет поле в базе данных. В этом случае после 
вычисления значения полей сохраняются в базе данных, и оттуда они извлекаются так же, 
как обычные поля, вместо того, чтобы повторно вычисляться во время выполнения. Благодаря 
декоратору @api.depends ORM будет знать, когда эти сохраненные значения необходимо пересчитать 
и обновить. Вы можете думать об этом как о постоянном кеше. Это также имеет то преимущество, 
что поле можно использовать для условий поиска, включая сортировку и группировку по операциям. 
Если вы используете store = True в своем поле вычислений, вам больше не нужно реализовывать 
метод поиска, потому что поле хранится в базе данных, и вы можете искать

Флаг compute_sudo = True должен использоваться в случаях, когда вычисления должны выполняться 
с повышенными привилегиями. Это может быть тот случай, когда при вычислении необходимо 
использовать данные, которые могут быть недоступны для конечного пользователя.

Важное примечание Значение по умолчанию compute_sudo изменено в Odoo v13. До Odoo v13 значение 
compute_sudo было False. Но в версии 13 значение по умолчанию compute_sudo будет основано на 
атрибутах хранилища. Если значение атрибута store равно True, то compute_sudo равно True или False. 
Однако вы всегда можете изменить его вручную, явно указав compute_ sudo в определении поля.

Это еще не все ... 

Odoo v13 представил новый механизм кеширования для ORM. Раньше кеш был основан на окружении, 
но теперь в Odoo v13 у нас есть один глобальный кеш. Итак, если у вас есть вычисляемое поле, 
которое зависит от значений контекста, вы можете иногда получать неверные значения. Чтобы 
решить эту проблему, вам нужно использовать декоратор @api.depends_context. Обратитесь к следующему примеру:

@api.depends('price')
@api.depends_context('company_id')
def _compute_value(self):
    company_id = self.env.context.get('company_id')
    ...
    # other computation

В предыдущем примере вы можете видеть, что в наших вычислениях используется company_id из контекста. 
Используя company_id в декораторе depends_context, мы гарантируем, что значение поля будет 
пересчитано на основе значения company_id в контексте.

Отображение связанных полей, хранящихся в других моделях

При чтении данных с сервера клиенты Odoo могут получать значения только для тех полей, 
которые доступны в модели и запрашиваются. Код на стороне клиента, в отличие от кода на 
стороне сервера, не может использовать точечную нотацию для доступа к данным в связанных таблицах.

Однако эти поля можно сделать доступными там, добавив их как связанные поля. Мы сделаем это, 
чтобы город издателя был доступен в модели «Library Books».

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Отредактируйте файл models /library_book.py, чтобы добавить новое связанное поле:

1. Убедитесь, что у нас есть поле для издателя книги:

class LibraryBook(models.Model):
    # ...
    publisher_id = fields.Many2one(
        'res.partner', string='Publisher')

2. Теперь добавьте соответствующее поле для города издателя:

# class LibraryBook(models.Model):
    # ...
    publisher_city = fields.Char(
        'Publisher City',
        related='publisher_id.city',
        readonly=True)
    
Наконец, нам нужно обновить дополнительный модуль, чтобы новые поля были доступны в модели.

Как это работает...

Связанные поля аналогичны обычным полям, но у них есть дополнительный атрибут, связанный со 
строкой для отдельной цепочки полей, которую необходимо пройти.

В нашем случае мы получаем доступ к записи, связанной с издателем, через publisher_id, а 
затем читаем ее поле города. У нас также могут быть более длинные цепочки, например 
publisher_id.country_id.country_code.

Обратите внимание, что в этом рецепте мы устанавливаем связанное поле только для чтения. 
Если мы этого не сделаем, поле будет доступно для записи, и пользователь может изменить его 
значение. Это приведет к изменению значения поля города связанного издателя. Хотя это может 
быть полезным побочным эффектом, следует проявлять осторожность. У всех книг, опубликованных 
одним и тем же издателем, будет обновлено поле publisher_city, что может не соответствовать 
ожиданиям пользователя.

Есть больше...

Связанные поля фактически являются вычисляемыми полями. Они просто предоставляют удобный 
сокращенный синтаксис для чтения значений полей из связанных моделей. В качестве вычисляемого 
поля это означает, что атрибут store также доступен. В качестве ярлыка они также имеют все атрибуты 
из указанного поля, такие как name, translatable, если требуется.

Кроме того, они поддерживают флаг related_sudo, аналогичный compute_sudo; если установлено значение 
True, цепочка полей просматривается без проверки прав доступа пользователя.

Использование связанных полей в методе create() может повлиять на производительность, поскольку 
вычисление этих полей откладывается до конца их создания. Итак, если у вас есть отношение One2many, 
например, в моделях sale.order и sale.order.line, и у вас есть связанное поле в линейной модели, 
ссылающееся на поле в модели заказа, вы должны явно прочитать поле в модель заказа во время создания 
записи, вместо использования ярлыка связанного поля, особенно если есть много строк.

Добавление динамических отношений с использованием справочных полей

В случае реляционных полей нам необходимо заранее определить целевую модель (или совместную модель) 
отношения. Однако иногда нам может потребоваться оставить это решение на усмотрение пользователя и 
сначала выбрать желаемую модель, а затем запись, на которую мы хотим создать ссылку.

В Odoo этого можно добиться с помощью справочных полей.

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Отредактируйте файл models /library_book.py, чтобы добавить новое связанное поле:

1. Во-первых, нам нужно добавить вспомогательный метод для динамического построения списка выбираемых 
целевых моделей:

from odoo import models, fields, api
class LibraryBook(models.Model):
    # ...
    @api.model
    def _referencable_models(self):
        models = self.env['ir.model'].search([
            ('field_id.name', '=', 'message_ids')])
        return [(x.model, x.name) for x in models]

2. Затем нам нужно добавить поле ссылки и использовать предыдущую функцию, чтобы предоставить 
список выбираемых моделей:        

ref_doc_id = fields.Reference(
    selection='_referencable_models',
    string='Reference Document')

Поскольку мы меняем структуру модели, для активации этих изменений необходимо обновление модуля.

Как это работает...

Справочные поля аналогичны полям типа "многие к одному", за исключением того, что они 
позволяют пользователю выбрать модель для ссылки.

Целевую модель можно выбрать из списка, предоставленного атрибутом selection. Атрибут 
selection должен быть списком из двух кортежей элементов, где первый - это внутренний идентификатор 
модели, а второй - ее текстовое описание.

Вот пример:

[('res.users', 'User'), ('res.partner', 'Partner')]

Однако вместо того, чтобы предоставлять фиксированный список, мы можем использовать наиболее 
распространенные модели. Для простоты мы используем все модели, в которых есть функция обмена 
сообщениями. Используя метод _referencable_models, мы предоставили список моделей динамически.

Наш рецепт начался с предоставления функции для просмотра всех записей модели, на которые можно ссылаться, 
для динамического создания списка, который будет предоставлен атрибуту выбора.
Хотя обе формы разрешены, мы объявили имя функции в кавычках, вместо того, чтобы напрямую 
ссылаться на функцию без кавычек. Это более гибкий подход, и он позволяет, например, определять 
функцию, на которую указывает ссылка, только позже в коде, что невозможно при использовании прямой ссылки.

Добавление функций в модель с помощью наследования

Одной из наиболее важных функций Odoo является способность надстроек модулей расширять функции, 
определенные в других надстройках модулей, без необходимости редактировать код исходной функции. 
Это может быть добавление полей или методов, изменение существующих полей или расширение существующих 
методов для выполнения дополнительной логики.

Согласно официальной документации, Odoo предоставляет три типа наследования:

• Наследование классов (расширение)

• Наследование прототипа

• Делегирование наследования

Мы увидим каждый из них в отдельном рецепте. В этом рецепте мы увидим наследование (расширение) класса. 
Он используется для добавления новых полей или методов к существующим моделям.

Мы расширим встроенную партнерскую модель res.partner, чтобы добавить ее в вычисляемое поле с количеством 
созданных книг. Это включает добавление поля и метода к существующей модели.

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Мы будем расширять встроенную партнерскую модель. Если вы помните, мы уже унаследовали модель 
res.parnter из раздела Добавление реляционных полей в рецепт модели в этой главе. Чтобы объяснение 
было как можно более простым, мы повторно будем использовать модель res.partner в файле кода 
models/library_book.py:

1. Во-первых, мы убедимся, что обратная связь authored_book_ids находится в модели партнера, 
и добавим вычисляемое поле:

class ResPartner(models.Model):
    _inherit = 'res.partner'
    _order = 'name'
    authored_book_ids = fields.Many2many(
        'library.book', string='Authored Books')
    count_books = fields.Integer( 'Number of Authored Books',
                                compute='_compute_count_books' )

2. Затем добавьте метод, необходимый для подсчета количества книг:

# ...
from odoo import api # if not already imported
# class ResPartner(models.Model):
    # ...
    @api.depends('authored_book_ids')
    def _compute_count_books(self):
        for r in self:
            r.count_books = len(r.authored_book_ids)

Наконец, нам нужно обновить дополнительный модуль, чтобы изменения вступили в силу.

Как это работает...

Когда класс модели определяется с помощью атрибута _inherit, он добавляет модификации к 
унаследованной модели, а не заменяет ее.

Это означает, что поля, определенные в наследующем классе, добавляются или изменяются в 
родительской модели. На уровне базы данных ORM добавляет поля в ту же таблицу базы данных.

Поля также постепенно изменяются. Это означает, что если поле уже существует в суперклассе, 
изменяются только атрибуты, объявленные в унаследованном классе; остальные остаются такими 
же, как и в родительском классе.

Методы, определенные в наследующем классе, заменяют методы в родительском классе. 
Если вы не вызовете родительский метод с помощью супервызова, в этом случае родительская 
версия метода не будет выполнена, и мы потеряем функции. Итак, всякий раз, когда вы 
добавляете новую логику, наследуя существующие методы, вы должны включать оператор с super 
для вызова его версии в родительском классе. Более подробно это обсуждается в главе 5, 
Базовая разработка на стороне сервера.

Этот рецепт добавит новые поля к существующей модели. Если вы также хотите добавить эти 
новые поля к существующим представлениям (пользовательскому интерфейсу), обратитесь к 
разделу «Изменение существующих представлений - рецепт наследования представлений» в 
главе 9, Внутренние представления.

Копировать определение модели с помощью наследования

Мы видели наследование (расширение) классов в предыдущем рецепте. Теперь мы увидим наследование 
прототипа, которое используется для копирования всего определения существующей модели.
В этом рецепте мы сделаем копию модели library.book.

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Наследование прототипа выполняется с использованием атрибутов класса _name и _inherit 
одновременно. Выполните следующие шаги, чтобы создать копию модели library.book:

1. Добавьте новый файл с именем library_book_copy.py в каталог /my_library/models/.

2. Добавьте следующее содержимое в файл library_book_copy.py:

from odoo import models, fields, api
class LibraryBookCopy(models.Model):
    _name = "library.book.copy"
    _inherit = "library.book"
    _description = "Library Book's Copy"

3. Импортируйте новую ссылку на файл в файл /my_library/models/__init__.py.
После изменений ваш файл __init__.py будет выглядеть так:

Наконец, нам нужно обновить дополнительный модуль, чтобы изменения вступили в силу. 
Чтобы проверить определение новой модели, перейдите в Настройки | Технические | 
Структура базы данных | Меню моделей. Здесь вы увидите новую запись для модели 
library.book.copy.

Кончик

Чтобы увидеть меню и представления для новой модели, необходимо добавить определение 
представлений и меню XML. Чтобы узнать больше о представлениях и меню, обратитесь к 
рецепту Добавление элементов меню и представлений в главе 3, Создание дополнительных 
модулей Odoo.

Как это работает...

Используя одновременно _name с атрибутом класса _inherit, вы можете скопировать 
определение модели. Когда вы используете оба атрибута в модели, Odoo скопирует 
определение модели _inherit и создаст новую модель с атрибутом _name.

В нашем примере Odoo скопирует определение модели library.book и создаст новую модель 
library.book.copy. Новая модель library.book.copy имеет собственную таблицу базы данных 
со своими собственными данными, которые полностью независимы от библиотека.
книга родительской модели. Поскольку он по-прежнему наследуется от партнерской модели, 
любые последующие изменения в нем также повлияют на новую модель.

Наследование прототипа копирует все свойства родительского класса. Он копирует поля, 
атрибуты и методы. Если вы хотите изменить их в дочернем классе, вы можете просто 
сделать это, добавив новое определение в дочерний класс. Например, модель library.book 
имеет метод _name_get. Если вы хотите использовать другую версию _name_get в дочернем 
элементе, вам необходимо переопределить метод в модели library.book.copy.

Предупреждение

Наследование прототипа не работает, если вы используете одно и то же имя модели 
в атрибутах _inherit и _name. Если вы используете одно и то же имя модели в 
атрибутах _inherit и _name, оно будет вести себя как обычное наследование 
расширений.

Есть больше…

В официальной документации это называется наследованием прототипа, но на практике 
используется редко. Причина этого в том, что наследование делегирования обычно 
отвечает на эту потребность более эффективным способом, без необходимости дублировать 
структуры данных. Для получения дополнительной информации об этом вы можете обратиться 
к следующему рецепту, Использование наследования с делегированием для копирования 
функций в другую модель.

Использование наследования с делегированием для копирования функций в другую модель

Третий тип наследования - наследование с делегированием. Вместо _inherit он использует 
атрибут класса _inherits. Бывают случаи, когда вместо изменения существующей модели 
мы хотим создать новую модель на основе существующей, чтобы использовать уже имеющиеся 
в ней функции. Мы можем скопировать определения модели с наследованием прототипа, но 
это создаст повторяющиеся структуры данных. Если вы хотите скопировать определения модели 
без дублирования структур данных, то ответ заключается в наследовании делегирования Odoo, 
которое использует атрибут модели _inherits (обратите внимание на дополнительные s).

Традиционное наследование сильно отличается от концепции объектно-ориентированного 
программирования. Наследование с делегированием, в свою очередь, аналогично тому, 
что новая модель может быть создана для включения функций из родительской модели. 
Он также поддерживает полиморфное наследование, при котором мы наследуем от двух 
или более других моделей.

У нас есть библиотека с книгами. Пора и в нашу библиотеку пополниться. Для члена 
библиотеки нам нужны все идентификационные и адресные данные, которые есть в 
партнерской модели, и мы также хотим, чтобы в ней сохранялась некоторая информация, 
относящаяся к членству: дата начала, дата прекращения и номер карты.

Добавление этих полей в партнерскую модель - не лучшее решение, поскольку они не 
будут использоваться для партнеров, которые не являются участниками. Было бы здорово 
расширить партнерскую модель до новой модели с некоторыми дополнительными полями.

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Новая модель члена библиотеки должна быть в отдельном файле кода Python, но чтобы 
объяснение было как можно более простым, мы будем повторно использовать файл 
models/library_book.py:

1. Добавьте новую модель, унаследованную от res.partner:

class LibraryMember(models.Model):
    _name = 'library.member'
    _inherits = {'res.partner': 'partner_id'}
    partner_id = fields.Many2one(
        'res.partner',
        ondelete='cascade')

2. Затем мы добавим поля, относящиеся к членам библиотеки:

# class LibraryMember(models.Model):
    # ...
    date_start = fields.Date('Member Since')
    date_end = fields.Date('Termination Date')
    member_number = fields.Char()
    date_of_birth = fields.Date('Date of birth')

Теперь мы должны обновить дополнительный модуль, чтобы изменения вступили в силу.

Как это работает...

Атрибут _inherits model устанавливает родительские модели, от которых мы хотим наследовать. 
В данном случае у нас только один - res.partner. Его значение представляет собой словарь 
«ключ-значение», где ключи - это унаследованные модели, а значения - это имена полей, 
которые использовались для связи с ними. Это поля Many2one, которые мы также должны 
определить в модели. В нашем примере partner_id - это поле, которое будет использоваться 
для связи с родительской моделью Partner.

Чтобы лучше понять, как это работает, давайте посмотрим, что происходит на уровне базы данных, 
когда мы создаем нового члена:

• В таблице res_partner создается новая запись.

• В таблице library_member создается новая запись.

• В поле partner_id таблицы library_member устанавливается идентификатор записи res_partner, 
созданной для нее.

Запись участника автоматически связывается с новой записью партнера. Это просто отношение 
«многие к одному», но механизм делегирования добавляет некоторую магию, так что поля 
партнера отображаются так, как будто они принадлежат записи члена, и новая запись партнера 
также автоматически создается с новым членом.

Итак, что произойдет, если вы удалите партнерскую запись, которая также является участником? 
Вы решаете, выбирая значение ondelete для поля отношения. Для partner_id мы использовали 
cascade. Это означает, что при удалении партнера будет удален и член-корреспондент. 
Мы могли бы использовать более консервативную настройку, ограничить, чтобы запретить 
удаление партнера, пока у него есть связанный член. В этом случае будет работать только 
удаление участника.

Важно отметить, что наследование делегирования работает только для полей, а не для методов. 
Итак, если у партнерской модели есть метод do_something(), модель членов не наследует 
его автоматически.

Есть больше...

Для этого делегирования наследования есть ярлык. Вместо создания словаря _inherits вы 
можете использовать атрибут delegate = True в определении поля Many2one.
Это будет работать точно так же, как опция _inherits. Главное преимущество в том, 
что это проще. В данном примере мы выполнили то же делегирование наследования, что и в 
предыдущем, но в этом случае вместо создания словаря _inherits мы использовали параметр 
delegate = True в поле partner_id:

class LibraryMember(models.Model):
    _name = 'library.member'
    partner_id = fields.Many2one('res.partner',
                                ondelete='cascade', delegate=True)
    date_start = fields.Date('Member Since')
    date_end = fields.Date('Termination Date')
    member_number = fields.Char()
    date_of_birth = fields.Date('Date of birth')

Примечательным случаем наследования делегирования является модель пользователей, 
res.users. Он наследуется от партнеров (res.partner). Это означает, что некоторые поля, 
которые вы видите у пользователя, на самом деле хранятся в модели партнера (в частности, 
поле имени). Когда создается новый пользователь, мы также получаем нового, автоматически 
созданного партнера.

Мы также должны упомянуть, что традиционное наследование с _inherit также может копировать 
функции в новую модель, хотя и менее эффективным способом. Это обсуждалось в разделе 
«Добавление элементов в модель с использованием рецепта наследования».

Использование абстрактных моделей для многоразовых функций модели

Иногда есть особая функция, которую мы хотим добавить к нескольким различным моделям. 
Повторение одного и того же кода в разных файлах - плохая практика программирования; 
лучше было бы реализовать его один раз и использовать повторно.

Абстрактные модели позволяют нам создать общую модель, которая реализует некоторые функции, 
которые затем могут быть унаследованы обычными моделями, чтобы сделать эту функцию доступной.

В качестве примера мы реализуем простую функцию архивирования. Он добавляет активное 
поле в модель (если оно еще не существует) и делает доступным метод архивирования для 
переключения активного флага. Это работает, потому что active - это магическое поле. Если 
они присутствуют в модели по умолчанию, записи с active = False будут отфильтрованы из запросов.

Затем мы добавим его в модель библиотечных книг.

Готовиться

Мы продолжим использовать дополнительный модуль my_library из предыдущего рецепта.

Как это сделать...

Функция архивирования, безусловно, заслуживает отдельного дополнительного модуля или, по 
крайней мере, собственного файла кода Python. Однако, чтобы объяснение было как можно более 
простым, мы поместим его в файл models/library_book.py:

1. Добавьте абстрактную модель для функции архива. Он должен быть определен в модели 
Library Book, где он будет использоваться:

class BaseArchive(models.AbstractModel):
    _name = 'base.archive'
    active = fields.Boolean(default=True)
    def do_archive(self):
        for record in self:
            record.active = not record.active

2. Теперь мы отредактируем модель Библиотечной книги, чтобы унаследовать модель архива:

class LibraryBook(models.Model):
    _name = 'library.book'
    _inherit = ['base.archive']
    # ...

Для активации изменений требуется обновление дополнительного модуля.

Как это работает...

Абстрактная модель создается классом на основе models.AbstractModel, а не обычных models.Model. 
Обладает всеми атрибутами и возможностями обычных моделей; разница в том, что ORM не создает 
для него фактического представления в базе данных.
Это означает, что в нем не может храниться никаких данных. Он служит только шаблоном для 
многоразового элемента, который должен быть добавлен к обычным моделям.

Абстрактная модель нашего архива довольно проста. Он просто добавляет активное поле и метод 
для переключения значения активного флага, который, как мы ожидаем, будет использоваться 
позже, с помощью кнопки в пользовательском интерфейсе.

Когда класс модели определяется с помощью атрибута _inherit, он наследует методы атрибутов 
этих классов, а методы атрибутов, определенные в текущем классе, добавляют модификации к 
этим унаследованным функциям.

Действующий здесь механизм такой же, как и у обычного расширения модели (в соответствии 
с добавлением функций в модель с использованием рецепта наследования). Вы могли заметить, 
что _inherit использует список идентификаторов модели вместо строки с одним идентификатором модели.
Фактически, _inherit может иметь обе формы. Использование формы списка позволяет нам 
наследовать от нескольких (обычно абстрактных) классов. В этом случае мы наследуем только 
один, поэтому текстовая строка подойдет. Вместо этого в иллюстративных целях 
использовался список.

Есть больше...

Примечательной встроенной абстрактной моделью является mail.thread, который предоставляется 
дополнительным модулем mail (Discuss). На моделях он включает функции обсуждения, которые 
поддерживают стену сообщений, которая видна внизу многих форм.

Помимо AbstractModel, доступен третий тип модели: models.TransientModel. У него есть 
представление базы данных, такое как models.Model, но записи, которые создаются там, 
должны быть временными и регулярно очищаться заданием, запланированным сервером. В 
остальном переходные модели работают так же, как и обычные модели.

models.TransientModel полезен для более сложных взаимодействий с пользователем, 
известных как мастера. Мастер используется для запроса ввода от пользователя. 
В главе 8 «Расширенные методы разработки на стороне сервера» мы исследуем, как их 
использовать для расширенного взаимодействия с пользователем.